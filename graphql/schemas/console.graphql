"""
Requires that exactly one field must be supplied and that field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

"""Exposes a URL that specifies the behavior of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behavior of this scalar."""
  url: String!
) on SCALAR

"""Autogenerated input type of AccountBacsDebitSun"""
input AccountBacsDebitSunInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practiceId: ID
  descriptor: String!
}

"""Autogenerated return type of AccountBacsDebitSun."""
type AccountBacsDebitSunPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

type ActivityLog {
  additionalInfo: String
  createdAt: DateTime!
  id: ID!
  level: ActivityLogLevel!
  message: String!
  relationId: ID!
  updatedAt: DateTime!
}

"""The connection type for ActivityLog."""
type ActivityLogConnection {
  """A list of edges."""
  edges: [ActivityLogEdge!]!

  """A list of nodes."""
  nodes: [ActivityLog!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ActivityLogEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: ActivityLog!
}

enum ActivityLogLevel {
  ERROR
  INFO
  SUCCESS
  WARNING
}

type AdminUser {
  createdAt: DateTime!
  email: EmailAddress!
  id: ID!
  roles: [String!]
  updatedAt: DateTime!
}

"""Autogenerated input type of AppClientsExport"""
input AppClientsExportInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The name of the app to filter on"""
  appName: AppNameEnum
}

"""Autogenerated return type of AppClientsExport."""
type AppClientsExportPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  export: Export!
}

enum AppNameEnum {
  QUICKBOOKS
  XERO
  XPM
}

type Audit {
  action: AuditAction!
  auditedChanges: JSON!
  comment: String
  createdAt: DateTime!
  referenceNumber: ID!
  user: AuditUserUnion
  version: Int!
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
}

"""The connection type for Audit."""
type AuditConnection {
  """A list of edges."""
  edges: [AuditEdge!]!

  """A list of nodes."""
  nodes: [Audit!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type AuditEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Audit!
}

"""Possible user type of audits"""
union AuditUserUnion = AdminUser | User

enum Author {
  """customer"""
  CUSTOMER

  """admin"""
  ADMIN

  """ledger"""
  LEDGER
}

type BackgroundJob {
  """sidekiq background job id"""
  id: String!

  """timestamp of when the job was queued"""
  queuedAt: DateTime!
}

type BacsDebitSunType {
  descriptor: String!
  id: ID!
  state: String!
}

"""Represents non-fractional signed whole numeric values."""
scalar BigInt

enum BillingGroupedByType {
  CLIENT
  PROPOSAL
  PROJECT
}

type BrandingTheme {
  colour: String!
  colourHex: String!
  defaultBrochure: Filestack
  defaultBrochureUrl: URL @deprecated(reason: "Use default_brochure { url } instead.")
  id: ID!

  """Tells you if the returned logo is the Ignition provided default."""
  isDefaultLogo: Boolean!
  logo: ResizeableImage!
  logoUrl: URL! @deprecated(reason: "Use logo { url } instead.")
}

type BulkKickOff {
  """Admin user"""
  adminUser: AdminUser!
  bulkKickOffType: BulkKickOffType!
  createdAt: DateTime!
  errors: [String!]
  file: Filestack!

  """The slug for this BKO record"""
  id: ID!

  """The number of proposals associated to this BKO"""
  proposalCount: Int!

  """The progress of sending proposals"""
  sendProgress: BulkKickOffSendProgress!
  status: BulkKickOffStatus!
}

"""Autogenerated input type of BulkKickoffArchiveProposals"""
input BulkKickoffArchiveProposalsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The slug of the bulk kickoff"""
  id: ID!

  """The ID of the Practice"""
  practiceId: ID!
}

"""Autogenerated return type of BulkKickoffArchiveProposals."""
type BulkKickoffArchiveProposalsPayload {
  bulkKickOff: BulkKickOff

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""The connection type for BulkKickOff."""
type BulkKickOffConnection {
  """A list of edges."""
  edges: [BulkKickOffEdge!]!

  """A list of nodes."""
  nodes: [BulkKickOff!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Autogenerated input type of BulkKickOffCreate"""
input BulkKickOffCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!
  bulkKickOffType: BulkKickOffType!
  importFile: FilestackInput!
}

"""Autogenerated return type of BulkKickOffCreate."""
type BulkKickOffCreatePayload {
  bulkKickOff: BulkKickOff

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  userErrors: [UserError!]
}

"""An edge in a connection."""
type BulkKickOffEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: BulkKickOff!
}

input BulkKickOffFilter {
  statusIn: [BulkKickOffStatus!]
  fileTypeEq: BulkKickOffType
}

type BulkKickOffSendProgress {
  lastNpeSent: DateTime
  numberNpe: Int!
  numberNpeAccepted: Int!
  numberNpeArchived: Int!
  numberNpeLost: Int!
  numberNpePending: Int!
  numberNpeSent: Int!
}

"""Autogenerated input type of BulkKickoffSendProposals"""
input BulkKickoffSendProposalsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The slug of the bulk kickoff"""
  id: ID!

  """The ID of the Practice"""
  practiceId: ID!

  """Send email to client"""
  sendToClient: Boolean
}

"""Autogenerated return type of BulkKickoffSendProposals."""
type BulkKickoffSendProposalsPayload {
  bulkKickOff: BulkKickOff

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

enum BulkKickOffStatus {
  ARCHIVED
  FAILED
  IMPORTED
  PENDING
  VALIDATED
  SENT_PROPOSALS
}

enum BulkKickOffType {
  CLIENTS
  ENGAGEMENT_MAPPING
  PROPOSAL_MAPPING
}

"""Autogenerated input type of CancelScheduledDisbursalsDisablement"""
input CancelScheduledDisbursalsDisablementInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice to cancel scheduled disbursals disablement for"""
  practiceId: ID!
}

"""Autogenerated return type of CancelScheduledDisbursalsDisablement."""
type CancelScheduledDisbursalsDisablementPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

type Client {
  audits(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): AuditConnection
  businessStructure: String
  canArchive: Boolean!
  cbsEnabled: Boolean!
  companyNumber: String
  contacts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ContactConnection!
  createdAt: DateTime!
  dashboardUri: String
  deletedAt: DateTime

  """Reference number for the client (eg. CLI-0001)"""
  displayReferenceNumber: String!
  emailAddress: EmailAddress @deprecated(reason: "emailAddress is no longer available on the client. Use the default contact email instead.")
  engagements(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: EngagementFilter
  ): EngagementConnection
  faxNumber: PhoneNumber
  gstRegistered: String
  id: ID!
  invoices(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: ClientBillingInvoiceFilter
  ): ClientBillingInvoiceConnection

  """
  Is revenue from this client excluded from the dashboard and other reports?
  """
  isExcludedFromReports: Boolean!

  """
  Whether the practice applies surcharges to pass on payment fees to this client
  """
  isSurchargeEnabled: Boolean!
  name: String!
  notes: String
  notificationsSettings(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: NotificationsSettingsFilter
  ): NotificationsSettingsConnection!
  paymentMethods: [PaymentMethod!]
  phoneNumber: PhoneNumber

  """Indicates if the client is a placeholder client for public previews"""
  placeholder: Boolean!
  practice: Practice!
  proposals(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: ProposalFilter
  ): ProposalConnection
  recipientGroup(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: RecipientGroupFilter
  ): RecipientGroupConnection!
  state: ClientState!
  type: ClientType!
  updatedAt: DateTime!
  websiteUrl: URL
}

"""Autogenerated input type of ClientAgreedServicesExport"""
input ClientAgreedServicesExportInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the practice."""
  practiceId: ID!

  """The id of the logged in user."""
  userId: ID!

  """
  Only agreed services with expiration on or after this date will be included.
  """
  expiresOnOrAfter: Date

  """The date to start calculating the total price of agreed services."""
  startDate: Date

  """The date to end calculating the total price of agreed services."""
  endDate: Date
}

"""Autogenerated return type of ClientAgreedServicesExport."""
type ClientAgreedServicesExportPayload {
  backgroundJob: BackgroundJob!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

type ClientBillingInvoice {
  activities(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ActivityLogConnection
  amount: Money!
  clawbackable: Boolean!
  client: Client!
  date: Date!
  deployments(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): InvoiceDeploymentConnection
  dueDate: Date!
  id: ID!
  items(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ClientBillingInvoiceItemConnection!
  latestDeployment: InvoiceDeployment
  memo: String
  payment: PaymentsPayment
  reference: String!
  refundable: Boolean!
  remoteInvoice: String
  remoteInvoiceHistory: String
  state: ClientBillingInvoiceState!
}

"""The connection type for ClientBillingInvoice."""
type ClientBillingInvoiceConnection {
  """A list of edges."""
  edges: [ClientBillingInvoiceEdge!]!

  """A list of nodes."""
  nodes: [ClientBillingInvoice!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ClientBillingInvoiceEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: ClientBillingInvoice!
}

input ClientBillingInvoiceFilter {
  idCont: String
}

type ClientBillingInvoiceItem {
  amount: Money!
  description: String
  discount: Money
  name: String!
  notes: String
  position: Int
  quantity: Decimal!
  unitPrice: Money!
}

"""The connection type for ClientBillingInvoiceItem."""
type ClientBillingInvoiceItemConnection {
  """A list of edges."""
  edges: [ClientBillingInvoiceItemEdge!]!

  """A list of nodes."""
  nodes: [ClientBillingInvoiceItem!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ClientBillingInvoiceItemEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: ClientBillingInvoiceItem!
}

enum ClientBillingInvoiceState {
  ISSUED
  DELETED
}

"""Autogenerated input type of ClientBulkArchive"""
input ClientBulkArchiveInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """Client tag"""
  tag: String!

  """Maximum number of clients to be archived"""
  maxSize: Int
}

"""Autogenerated return type of ClientBulkArchive."""
type ClientBulkArchivePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

"""The connection type for Client."""
type ClientConnection {
  """A list of edges."""
  edges: [ClientEdge!]!

  """A list of nodes."""
  nodes: [Client!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ClientEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Client!
}

input ClientFilter {
  """Filters clients by name only."""
  nameCont: String

  """Filters clients by name or associated contact email"""
  nameOrContactsEmailCont: String
  stateNotIn: [ClientState!]
  proposalFilter: ProposalFilter
}

"""Autogenerated input type of ClientGenerateProposalTemplatePreviews"""
input ClientGenerateProposalTemplatePreviewsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The ID of the client"""
  clientId: ID!
}

"""Autogenerated return type of ClientGenerateProposalTemplatePreviews."""
type ClientGenerateProposalTemplatePreviewsPayload {
  client: Client

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

"""Autogenerated input type of ClientMerge"""
input ClientMergeInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The ID of the source client"""
  sourceClientId: ID!

  """The ID of the target client"""
  destinationClientId: ID!
}

"""Autogenerated return type of ClientMerge."""
type ClientMergePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  destination: Client
  source: Client
  userErrors: [UserError!]
}

enum ClientsCount {
  """2000+ clients"""
  TWO_THOUSAND_PLUS

  """1001-2000 clients"""
  ONE_THOUSAND_AND_ONE_TO_TWO_THOUSAND

  """501-1000 clients"""
  FIVE_HUNDRED_AND_ONE_TO_ONE_THOUSAND

  """251-500 clients"""
  TWO_HUNDRED_FIFTY_ONE_TO_FIVE_HUNDRED

  """101-250 clients"""
  ONE_HUNDRED_AND_ONE_TO_TWO_HUNDRED_FIFTY

  """61-100 clients"""
  SIXTY_ONE_TO_ONE_HUNDRED

  """31-60 clients"""
  THIRTY_ONE_TO_SIXTY

  """1-30 clients"""
  ONE_TO_THIRTY @deprecated(reason: "split into ZERO_TO_NINE and TEN_TO_THIRTY instead")

  """10-30 clients"""
  TEN_TO_THIRTY

  """0-9 clients"""
  ZERO_TO_NINE
}

"""Autogenerated input type of ClientSetExcludeFromReports"""
input ClientSetExcludeFromReportsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The ID of the client"""
  clientId: ID!
  excludeFromReports: Boolean!
}

"""Autogenerated return type of ClientSetExcludeFromReports."""
type ClientSetExcludeFromReportsPayload {
  client: Client

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

enum ClientState {
  LEAD
  ACTIVE
  INACTIVE
  LOST
  DELETED
  ARCHIVED
}

enum ClientType {
  """Normal clients created by practices"""
  STANDARD

  """
  Client used to demonstrate features without influencing real client data.
  """
  DEMO
}

type Contact {
  emailAddress: EmailAddress
  id: ID!
  isDefault: Boolean!
  mobileNumber: PhoneNumber
  name: String!
  phoneNumber: PhoneNumber
  position: String
}

"""The connection type for Contact."""
type ContactConnection {
  """A list of edges."""
  edges: [ContactEdge!]!

  """A list of nodes."""
  nodes: [Contact!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ContactEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Contact!
}

type Currency {
  """character between the whole and fraction amounts"""
  decimalMark: String!

  """the international 3-letter code as defined by the ISO 4217 standard"""
  isoCode: String!

  """the international 3-digit code as defined by the ISO 4217 standard"""
  isoNumeric: String!

  """the currency name"""
  name: String!

  """a numerical value you can use to sort/group the currency list"""
  priority: Int!

  """the name of the fractional monetary unit"""
  subunit: String!

  """the proportion between the unit and the subunit"""
  subunitToUnit: Int!

  """the currency symbol (UTF-8 encoded)"""
  symbol: String!

  """character between each thousands place"""
  thousandsSeparator: String!
}

type CustomerSuccessEngagementLetter {
  createdAt: DateTime!
  creator: User!
  file: Filestack!
  id: ID!
  state: EngagementLetterState!
}

"""The connection type for CustomerSuccessEngagementLetter."""
type CustomerSuccessEngagementLetterConnection {
  """A list of edges."""
  edges: [CustomerSuccessEngagementLetterEdge!]!

  """A list of nodes."""
  nodes: [CustomerSuccessEngagementLetter!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type CustomerSuccessEngagementLetterEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: CustomerSuccessEngagementLetter!
}

type CustomerSuccessMaturityIndex {
  author: Author
  clientsCount: ClientsCount!
  createdAt: DateTime!
  id: ID!
  industry: Industry!
  ledger: Ledger!
  projectedPercentGrowthForThisYear: Percentage

  """The label of the revenue bracket selected by the user in the CMI form"""
  revenueBracketLabel: String

  """Revenue collected from the ledger if one is connected"""
  revenueFromLedger: Money

  """Revenue last year collected from dashboard"""
  revenueLastYear: Money
  score: Decimal!

  """The calculation version used to generate the CMI index score"""
  version: Int!
}

"""Autogenerated input type of CustomerSuccessMaturityIndexCalculate"""
input CustomerSuccessMaturityIndexCalculateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customerSuccessMaturityIndex: MaturityIndexInput!
}

"""Autogenerated return type of CustomerSuccessMaturityIndexCalculate."""
type CustomerSuccessMaturityIndexCalculatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customerSuccessMaturityIndex: CustomerSuccessMaturityIndexUnion
}

"""Possible maturity index types based on version"""
union CustomerSuccessMaturityIndexUnion = CustomerSuccessMaturityIndex | CustomerSuccessVersion1MaturityIndex

"""The connection type for CustomerSuccessMaturityIndexUnion."""
type CustomerSuccessMaturityIndexUnionConnection {
  """A list of edges."""
  edges: [CustomerSuccessMaturityIndexUnionEdge]

  """A list of nodes."""
  nodes: [CustomerSuccessMaturityIndexUnion]

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type CustomerSuccessMaturityIndexUnionEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: CustomerSuccessMaturityIndexUnion
}

type CustomerSuccessReferralCopy {
  createdAt: DateTime
  description: String
  publisher: AdminUser
  title: String
  updatedAt: DateTime
}

type CustomerSuccessVersion1MaturityIndex {
  author: Author
  clientsCount: ClientsCount!
  createdAt: DateTime!
  feeStructure: FeeStructure
  id: ID!
  industry: Industry!
  ledger: Ledger!
  paymentCollectionTool: MaturityIndexPaymentCollectionToolEnum
  paymentCollectionToolOther: String
  projectedPercentGrowthForThisYear: Percentage

  """
  The projected percent growth bracket in the version 1 configuration file
  """
  projectedPercentGrowthForThisYearBracket: MaturityIndexGrowthPercentageBracketEnum

  """Revenue last year collected from dashboard"""
  revenueLastYear: Money

  """
  The bracket that the practice's revenue is mapped in the version 1 configuration file
  """
  revenueLastYearBracket: MaturityIndexRevenueBracketEnum
  score: Decimal!
  staffCount: StaffCount

  """The calculation version used to generate the CMI index score"""
  version: Int!
  workflowTool: MaturityIndexWorkflowToolEnum
  workflowToolOther: String
}

"""The connection type for ProposalEditorCustomTemplate."""
type CustomTemplateConnection {
  """A list of edges."""
  edges: [CustomTemplateEdge!]!

  """A list of nodes."""
  nodes: [ProposalEditorCustomTemplate!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
  templatesYaml: String!
}

"""Autogenerated input type of CustomTemplateCreateFromTemplateData"""
input CustomTemplateCreateFromTemplateDataInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The template name"""
  name: String!

  """The template description"""
  description: String!

  """The template_data in JSON format"""
  templateData: String!
}

"""Autogenerated return type of CustomTemplateCreateFromTemplateData."""
type CustomTemplateCreateFromTemplateDataPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customTemplate: ProposalEditorCustomTemplate
}

"""Autogenerated input type of CustomTemplateDelete"""
input CustomTemplateDeleteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The ID of the custom template"""
  customTemplateId: ID!
}

"""Autogenerated return type of CustomTemplateDelete."""
type CustomTemplateDeletePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customTemplate: ProposalEditorCustomTemplate
}

"""An edge in a connection."""
type CustomTemplateEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: ProposalEditorCustomTemplate!
}

input CustomTemplateFilter {
  """Name of the template"""
  nameCont: String
}

input CustomTemplatePublishSettingsInputType {
  """The type of visibility: PRIVATE|PUBLIC|DEMO"""
  visibility: CustomTemplateVisibilityState

  """The source_type: IGNITION|APP"""
  sourceType: CustomTemplateSourceType

  """The name of the source (used for tracking)"""
  sourceName: String

  """The name of the app. Required if source_type == APP"""
  appName: String

  """The URL of the optional logo (if different from default)"""
  logoUrl: String

  """Comment made by publisher when approving template"""
  publishComment: String

  """Override the original name of the template"""
  name: String

  """Override the original description of the template"""
  description: String

  """The name of author of the template"""
  authorName: String

  """The organization or group the author belongs to"""
  authorEntity: String

  """The logo of the author entity"""
  authorLogoUrl: String

  """Description of provided templates with formatting"""
  longDescription: String
}

enum CustomTemplateSourceType {
  APP
  IGNITION
}

"""Autogenerated input type of CustomTemplateUpdateFromProposal"""
input CustomTemplateUpdateFromProposalInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The ID of the custom template"""
  customTemplateId: ID!

  """The ID of the proposal"""
  proposalId: ID!

  """The ID of the proposal's practice"""
  proposalPracticeId: ID!

  """Comment made by publisher when approving template"""
  publishComment: String
}

"""Autogenerated return type of CustomTemplateUpdateFromProposal."""
type CustomTemplateUpdateFromProposalPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customTemplate: ProposalEditorCustomTemplate
}

"""Autogenerated input type of CustomTemplateUpdatePublishSettings"""
input CustomTemplateUpdatePublishSettingsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The ID of the custom template"""
  customTemplateId: ID!

  """The publish settings of a custom template"""
  publishSettingsInput: CustomTemplatePublishSettingsInputType!
}

"""Autogenerated return type of CustomTemplateUpdatePublishSettings."""
type CustomTemplateUpdatePublishSettingsPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customTemplate: ProposalEditorCustomTemplate
}

"""Autogenerated input type of CustomTemplateUpdateTemplateData"""
input CustomTemplateUpdateTemplateDataInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The ID of the custom template"""
  customTemplateId: ID!

  """The template_data in JSON format"""
  templateData: String!

  """Comment made by publisher when approving template"""
  publishComment: String
}

"""Autogenerated return type of CustomTemplateUpdateTemplateData."""
type CustomTemplateUpdateTemplateDataPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customTemplate: ProposalEditorCustomTemplate
}

enum CustomTemplateVisibilityState {
  PRIVATE
  PUBLIC
  DEMO
}

"""ISO8601 formatted date (yyyy-mm-dd)"""
scalar Date

scalar DateTime

scalar Decimal

"""Autogenerated input type of DisbursalsDisable"""
input DisbursalsDisableInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice to disable disbursals for"""
  practiceId: ID
}

enum DisbursalsDisablementType {
  KYC_REQUIRED
  FRAUD_DETECTION
  SUBSCRIPTION_EXPIRED
  DISBURSAL_ACCOUNT_CHANGED
  REJECTED_BY_STAFF
  STRIPE_PAYOUTS_DISABLED
}

"""Autogenerated return type of DisbursalsDisable."""
type DisbursalsDisablePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

"""Autogenerated input type of DisbursalsEnable"""
input DisbursalsEnableInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practiceId: ID
}

"""Autogenerated return type of DisbursalsEnable."""
type DisbursalsEnablePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

scalar EmailAddress

type Engagement {
  acceptLink: URL!
  audits(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): AuditConnection
  child: Engagement
  client: Client
  events(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): EventsEventConnection

  """Engagement's UUID"""
  id: ID!
  name: String!
  parent: Engagement
  pdfUrl: URL!
  practice: Practice!
  referenceNumber: ID!
  state: EngagementState!
  totalValue: Money!
}

"""Autogenerated input type of EngagementClientChange"""
input EngagementClientChangeInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practiceId: ID!
  sourceClientId: ID!
  targetClientId: ID!
}

"""Autogenerated return type of EngagementClientChange."""
type EngagementClientChangePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  source: Client
  target: Client
  userErrors: [UserError!]
}

"""The connection type for Engagement."""
type EngagementConnection {
  """A list of edges."""
  edges: [EngagementEdge!]!

  """A list of nodes."""
  nodes: [Engagement!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type EngagementEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Engagement!
}

input EngagementFilter {
  stateEq: EngagementState
  nameCont: String
}

"""Autogenerated input type of EngagementLetterDelete"""
input EngagementLetterDeleteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The UUID of the Engagement"""
  engagementLetterId: ID!

  """The ID of the Practice"""
  practiceId: ID!
}

"""Autogenerated return type of EngagementLetterDelete."""
type EngagementLetterDeletePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  engagementLetter: CustomerSuccessEngagementLetter!
}

"""Autogenerated input type of EngagementLetterIntegrate"""
input EngagementLetterIntegrateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The UUID of the Engagement"""
  engagementLetterId: ID!

  """The ID of the Practice"""
  practiceId: ID!
}

"""Autogenerated return type of EngagementLetterIntegrate."""
type EngagementLetterIntegratePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  engagementLetter: CustomerSuccessEngagementLetter!
}

enum EngagementLetterState {
  INTEGRATED
  PENDING
  DELETED
}

enum EngagementState {
  ACTIVE
  COMPLETED
  DELETED
  DRAFT
  LOST
  QUEUED
  SENT
}

type EventsEvent {
  body: String!
  createdAt: DateTime!
  creationTime: DateTime! @deprecated(reason: "Use createdAt")
  id: ID!
  name: String!
  subdomain: String!
}

"""The connection type for EventsEvent."""
type EventsEventConnection {
  """A list of edges."""
  edges: [EventsEventEdge!]!

  """A list of nodes."""
  nodes: [EventsEvent!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type EventsEventEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: EventsEvent!
}

type Export {
  id: ID!
  search: String
  user: User!
}

type Feature {
  description: String!
  id: ID!
  isAvailable: Boolean!
  isEnabled: Boolean!
  isOverridden: Boolean!
  name: String!
}

type FeatureFlag {
  id: String!
  isEnabled: Boolean!
}

"""Autogenerated input type of FeatureOverride"""
input FeatureOverrideInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The id of the feature to override"""
  id: ID!
  available: Boolean!
}

"""Autogenerated return type of FeatureOverride."""
type FeatureOverridePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  feature: Feature!
}

"""Autogenerated input type of FeatureRemoveOverride"""
input FeatureRemoveOverrideInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The id of the feature to override"""
  id: ID!
}

"""Autogenerated return type of FeatureRemoveOverride."""
type FeatureRemoveOverridePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  feature: Feature!
}

enum FeeStructure {
  """as recurring fixed fees"""
  RECURRING_FIXED_FEES

  """as fixed fee project work"""
  FIXED_FEE_PROJECT_WORK

  """hourly but switching to fixed fees"""
  HOURLY_BUT_SWITCHING

  """hourly"""
  HOURLY
}

type Filestack {
  """The name of the file that was uploaded."""
  filename: String!

  """
  The Filestack file handle. This is useful because other Filestack methods accept handles as their input.
  """
  handle: ID!

  """The mimetype of the file, if available."""
  mimetype: String

  """
  This field is reported by the picker at the time the file is uploaded. It is
  the location where the file was selected from. This can be the location in a
  user's local file system, or the id or path reported by a cloud drive.
  """
  originalPath: String!

  """
  The size of the file in bytes, if available. We will attach this directly to
  the returned metadata when we have it, otherwise you can always get the size
  by calling client.metadata(handle)
  """
  size: Int!

  """
  The source the file was uploaded from. This could be 'local_file_system', 'instagram', 'dropbox' or any other source.
  """
  source: String!

  """
  The status of the upload. This is not returned if the Filestack link is a
  symbolic link. Possible statuses are: 'Stored', 'InTransit', and 'Failed'.
  'InTransit' means the file has not yet been copied to your bucket, but the
  Filestack link is valid and won't change once the status changes to 'Stored'.
  If you have configured webhooks, you will receive a webhook when the status
  changes to 'Stored'.
  """
  status: String

  """
  This string value is a UUID that can be used to track files in callbacks.
  """
  uploadId: String!

  """The Filestack URL that points to the uploaded file."""
  url: URL!
}

input FilestackInput {
  filename: String!
  handle: ID!
  mimetype: String
  originalPath: String!
  size: Int!
  source: String!
  status: String
  uploadId: String!
  url: URL!
}

enum Industry {
  """accounting"""
  ACCOUNTING

  """bookkeeping"""
  BOOKKEEPING

  """coaching"""
  COACHING

  """consulting"""
  CONSULTING

  """digital agency"""
  DIGITAL_AGENCY

  """financial services"""
  FINANCIAL_SERVICES

  """IT solutions"""
  IT_SOLUTIONS

  """law"""
  LAW

  """software"""
  SOFTWARE

  """other"""
  OTHER
}

type Integration {
  id: ID!
  name: String!
  state: String!
}

"""The connection type for Integration."""
type IntegrationConnection {
  """A list of edges."""
  edges: [IntegrationEdge!]!

  """A list of nodes."""
  nodes: [Integration!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type IntegrationEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Integration!
}

input IntegrationFilter {
  nameEq: IntegrationType
}

enum IntegrationType {
  XERO
  WORKFLOWMAX
  QBO
}

type InterchangeFee {
  """
  Card categorisation type, based on the % of interchange fees attributed to a payment collection
  """
  cardType: InterchangeFeeCardType!

  """Additional fee on top of the % fee, eg. 2.5% + 30c per transaction"""
  feeAddition: Money!

  """Percentage fee of an interchange fee, eg. 2.5%"""
  feePercentage: Percentage!
}

enum InterchangeFeeCardType {
  STANDARD
  PREMIUM
}

"""The connection type for InterchangeFee."""
type InterchangeFeeConnection {
  """A list of edges."""
  edges: [InterchangeFeeEdge!]!

  """A list of nodes."""
  nodes: [InterchangeFee!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type InterchangeFeeEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: InterchangeFee!
}

type InvoiceDeployment {
  completedAt: DateTime
  externalId: String
  externalNumber: String
  externalUrl: String
  failedAt: DateTime
  id: ID!
  ledgerName: String!
  message: String
  reference: ID!
  startedAt: DateTime
  state: InvoiceDeploymentState!
}

"""The connection type for InvoiceDeployment."""
type InvoiceDeploymentConnection {
  """A list of edges."""
  edges: [InvoiceDeploymentEdge!]!

  """A list of nodes."""
  nodes: [InvoiceDeployment!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type InvoiceDeploymentEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: InvoiceDeployment!
}

enum InvoiceDeploymentState {
  STARTED
  COMPLETED
  FAILED
}

scalar IpAddress

"""Represents untyped JSON"""
scalar JSON

enum Ledger {
  """Xero"""
  XERO

  """QuickBooks Online"""
  QUICKBOOKS_ONLINE

  """a different cloud ledger"""
  CLOUD_LEDGER

  """a desktop ledger"""
  DESKTOP_LEDGER
}

enum MaturityIndexGrowthPercentageBracketEnum {
  """Low growth"""
  LOW_GROWTH

  """Medium growth"""
  MEDIUM_GROWTH

  """High growth"""
  HIGH_GROWTH
}

input MaturityIndexInput {
  clientsCount: ClientsCount!
  feeStructure: FeeStructure
  industry: Industry!
  ledger: Ledger!
  staffCount: StaffCount
  practiceId: ID!
  workflowTool: MaturityIndexWorkflowToolEnum
  workflowToolOther: String
  paymentCollectionTool: MaturityIndexPaymentCollectionToolEnum
  paymentCollectionToolOther: String
  revenueLastYear: BigInt
  projectedPercentGrowthForThisYear: BigInt
  revenueBracket: MaturityIndexRevenueBracketValueEnum
}

enum MaturityIndexPaymentCollectionToolEnum {
  """Clients pay invoices with bank transfer/direct deposit"""
  CLIENTS_PAY_INVOICES_WITH_BANK_TRANSFER_DIRECT_DEPOSIT

  """Clients pay invoices with cheque or cash"""
  CLIENTS_PAY_INVOICES_WITH_CHEQUE_OR_CASH

  """Client sets up recurring standing order/eft"""
  CLIENT_SETS_UP_RECURRING_STANDING_ORDER_EFT

  """Point of Sale/Terminal"""
  POINT_OF_SALE_TERMINAL

  """Square Terminal"""
  SQUARE_TERMINAL

  """Bpay (AU)"""
  BPAY_AU

  """Interac eTransfer (CA)"""
  INTERAC_ETRANSFER_CA

  """Paypal"""
  PAYPAL

  """GoCardless (Direct)"""
  GOCARDLESS_DIRECT

  """Stripe (Direct)"""
  STRIPE_DIRECT

  """Xero Online payments w/ Stripe"""
  XERO_ONLINE_PAYMENTS_W_STRIPE

  """Xero Online payments w/ Gocardless"""
  XERO_ONLINE_PAYMENTS_W_GOCARDLESS

  """Square Online Payments"""
  SQUARE_ONLINE_PAYMENTS

  """QuickBooks Payments"""
  QUICKBOOKS_PAYMENTS

  """EziDebit/e-way (AU)"""
  EZIDEBIT_E_WAY_AU

  """Rotessa (CA)"""
  ROTESSA_CA

  """bill.com (US)"""
  BILL_COM_US

  """authorize.net"""
  AUTHORIZE_NET

  """Canopy Tax"""
  CANOPY_TAX

  """London & Zurich"""
  LONDON_ZURICH

  """Merchant account via my bank"""
  MERCHANT_ACCOUNT_VIA_MY_BANK

  """I use/I intend to use Ignition Payments"""
  PRACTICE_IGNITION_PAYMENTS

  """Other"""
  OTHER
}

enum MaturityIndexRevenueBracketEnum {
  """Low revenue"""
  LOW_REVENUE

  """Medium revenue"""
  MEDIUM_REVENUE

  """High revenue"""
  HIGH_REVENUE
}

enum MaturityIndexRevenueBracketValueEnum {
  LOWEST
  LOW
  LOW_MID
  HIGH_MID
  HIGH
  HIGHEST
}

enum MaturityIndexWorkflowToolEnum {
  """None"""
  NONE

  """Xero Practice Manager"""
  XERO_PRACTICE_MANAGER

  """Intuit Practice Manager"""
  INTUIT_PRACTICE_MANAGER

  """Karbon"""
  KARBON

  """Workflow Max"""
  WORKFLOW_MAX

  """Aero workflow"""
  AERO_WORKFLOW

  """Jetpack workflow"""
  JETPACK_WORKFLOW

  """Senta"""
  SENTA

  """Asana"""
  ASANA

  """Trello"""
  TRELLO

  """HubSpot"""
  HUBSPOT

  """Airtable"""
  AIRTABLE

  """Clickup"""
  CLICKUP

  """Zoho CRM"""
  ZOHO_CRM

  """Monday.com"""
  MONDAY_COM

  """Pixie"""
  PIXIE

  """Capium"""
  CAPIUM

  """AccountancyManager (UK)"""
  ACCOUNTANCYMANAGER_UK

  """APS / Reckon"""
  APS_RECKON

  """IRIS"""
  IRIS

  """CCH iFirm"""
  CCH_IFIRM

  """Digita"""
  DIGITA

  """QuickBooks Online Accountant"""
  QUICKBOOKS_ONLINE_ACCOUNTANT

  """TaxCalc"""
  TAXCALC

  """Thomson Reuters Practice CS"""
  THOMSON_REUTERS_PRACTICE_CS

  """Sage Handisoft"""
  SAGE_HANDISOFT

  """IRIS Practice Engine"""
  IRIS_PRACTICE_ENGINE

  """Nomisma"""
  NOMISMA

  """Microsoft Dynamics"""
  MICROSOFT_DYNAMICS

  """CCH axcess"""
  CCH_AXCESS

  """Onvio"""
  ONVIO

  """Microsoft Excel"""
  MICROSOFT_EXCEL

  """Google sheets"""
  GOOGLE_SHEETS

  """In-house built solution"""
  IN_HOUSE_BUILT_SOLUTION

  """Other"""
  OTHER
}

type Money {
  cents: BigInt!
  currency: Currency!
  dollars: Decimal!
  format: String!
}

input MoneyInput {
  currency: String!
  cents: BigInt!
}

type Mutation {
  accountBacsDebitSun(
    """Parameters for AccountBacsDebitSun"""
    input: AccountBacsDebitSunInput!
  ): AccountBacsDebitSunPayload @deprecated(reason: "use PracticeOnboardPayments instead, which implicitly sets up the SUN and other things")
  appClientsExport(
    """Parameters for AppClientsExport"""
    input: AppClientsExportInput!
  ): AppClientsExportPayload

  """
  Archive all the "ready" proposals for the kickoff in case a mistake was made with the BKO
  """
  bulkKickOffArchiveProposals(
    """Parameters for BulkKickoffArchiveProposals"""
    input: BulkKickoffArchiveProposalsInput!
  ): BulkKickoffArchiveProposalsPayload
  bulkKickOffCreate(
    """Parameters for BulkKickOffCreate"""
    input: BulkKickOffCreateInput!
  ): BulkKickOffCreatePayload

  """Schedule the send of all the "ready" proposals for the kickoff"""
  bulkKickOffSendProposals(
    """Parameters for BulkKickoffSendProposals"""
    input: BulkKickoffSendProposalsInput!
  ): BulkKickoffSendProposalsPayload
  cancelScheduledDisbursalsDisablement(
    """Parameters for CancelScheduledDisbursalsDisablement"""
    input: CancelScheduledDisbursalsDisablementInput!
  ): CancelScheduledDisbursalsDisablementPayload

  """Exports clients' agreed services"""
  clientAgreedServicesExport(
    """Parameters for ClientAgreedServicesExport"""
    input: ClientAgreedServicesExportInput!
  ): ClientAgreedServicesExportPayload
  clientBulkArchive(
    """Parameters for ClientBulkArchive"""
    input: ClientBulkArchiveInput!
  ): ClientBulkArchivePayload
  clientGenerateProposalTemplatePreviews(
    """Parameters for ClientGenerateProposalTemplatePreviews"""
    input: ClientGenerateProposalTemplatePreviewsInput!
  ): ClientGenerateProposalTemplatePreviewsPayload
  clientMerge(
    """Parameters for ClientMerge"""
    input: ClientMergeInput!
  ): ClientMergePayload
  clientSetExcludeFromReports(
    """Parameters for ClientSetExcludeFromReports"""
    input: ClientSetExcludeFromReportsInput!
  ): ClientSetExcludeFromReportsPayload
  customTemplateCreateFromTemplateData(
    """Parameters for CustomTemplateCreateFromTemplateData"""
    input: CustomTemplateCreateFromTemplateDataInput!
  ): CustomTemplateCreateFromTemplateDataPayload
  customTemplateDelete(
    """Parameters for CustomTemplateDelete"""
    input: CustomTemplateDeleteInput!
  ): CustomTemplateDeletePayload
  customTemplateUpdateFromProposal(
    """Parameters for CustomTemplateUpdateFromProposal"""
    input: CustomTemplateUpdateFromProposalInput!
  ): CustomTemplateUpdateFromProposalPayload
  customTemplateUpdatePublishSettings(
    """Parameters for CustomTemplateUpdatePublishSettings"""
    input: CustomTemplateUpdatePublishSettingsInput!
  ): CustomTemplateUpdatePublishSettingsPayload
  customTemplateUpdateTemplateData(
    """Parameters for CustomTemplateUpdateTemplateData"""
    input: CustomTemplateUpdateTemplateDataInput!
  ): CustomTemplateUpdateTemplateDataPayload
  customerSuccessMaturityIndexCalculate(
    """Parameters for CustomerSuccessMaturityIndexCalculate"""
    input: CustomerSuccessMaturityIndexCalculateInput!
  ): CustomerSuccessMaturityIndexCalculatePayload
  disbursalsDisable(
    """Parameters for DisbursalsDisable"""
    input: DisbursalsDisableInput!
  ): DisbursalsDisablePayload
  disbursalsEnable(
    """Parameters for DisbursalsEnable"""
    input: DisbursalsEnableInput!
  ): DisbursalsEnablePayload
  engagementClientChange(
    """Parameters for EngagementClientChange"""
    input: EngagementClientChangeInput!
  ): EngagementClientChangePayload @deprecated(reason: "Use clientMerge instead")
  engagementLetterDelete(
    """Parameters for EngagementLetterDelete"""
    input: EngagementLetterDeleteInput!
  ): EngagementLetterDeletePayload
  engagementLetterIntegrate(
    """Parameters for EngagementLetterIntegrate"""
    input: EngagementLetterIntegrateInput!
  ): EngagementLetterIntegratePayload
  featureOverride(
    """Parameters for FeatureOverride"""
    input: FeatureOverrideInput!
  ): FeatureOverridePayload
  featureRemoveOverride(
    """Parameters for FeatureRemoveOverride"""
    input: FeatureRemoveOverrideInput!
  ): FeatureRemoveOverridePayload
  paymentClawback(
    """Parameters for PaymentClawback"""
    input: PaymentClawbackInput!
  ): PaymentClawbackPayload
  paymentRefund(
    """Parameters for PaymentRefund"""
    input: PaymentRefundInput!
  ): PaymentRefundPayload
  paymentRefundApprove(
    """Parameters for PaymentRefundApprove"""
    input: PaymentRefundApproveInput!
  ): PaymentRefundApprovePayload
  paymentRefundDecline(
    """Parameters for PaymentRefundDecline"""
    input: PaymentRefundDeclineInput!
  ): PaymentRefundDeclinePayload
  paymentReverse(
    """Parameters for PaymentReverse"""
    input: PaymentReverseInput!
  ): PaymentReversePayload
  practiceBillingSetSubscription(
    """Parameters for practiceBillingSetSubscription"""
    input: practiceBillingSetSubscriptionInput!
  ): practiceBillingSetSubscriptionPayload
  practiceDeleteArchivedClients(
    """Parameters for PracticDeleteArchivedClients"""
    input: PracticDeleteArchivedClientsInput!
  ): PracticDeleteArchivedClientsPayload
  practiceDisable(
    """Parameters for PracticeDisable"""
    input: PracticeDisableInput!
  ): PracticeDisablePayload
  practiceEnable(
    """Parameters for PracticeEnable"""
    input: PracticeEnableInput!
  ): PracticeEnablePayload
  practiceFeatureFlagEnable(
    """Parameters for PracticeFeatureFlagEnable"""
    input: PracticeFeatureFlagEnableInput!
  ): PracticeFeatureFlagEnablePayload

  """
  Undoes the application of a template to the payments setup of a customer. Raises an error if a preset is not applied.
  """
  practiceOffboardPayments(
    """Parameters for PracticeOffboardPayments"""
    input: PracticeOffboardPaymentsInput!
  ): PracticeOffboardPaymentsPayload

  """
  Apply a template to the payments setup of a customer. May be done multiple times.
  """
  practiceOnboardPayments(
    """Parameters for PracticeOnboardPayments"""
    input: PracticeOnboardPaymentsInput!
  ): PracticeOnboardPaymentsPayload
  practiceSetCustomActiveClientLimit(
    """Parameters for PracticeSetCustomActiveClientLimit"""
    input: PracticeSetCustomActiveClientLimitInput!
  ): PracticeSetCustomActiveClientLimitPayload
  practiceSetFraudPaymentThreshold(
    """Parameters for PracticeSetFraudPaymentThreshold"""
    input: PracticeSetFraudPaymentThresholdInput!
  ): PracticeSetFraudPaymentThresholdPayload
  practiceSetPlanOveragesEnabled(
    """Parameters for PracticeSetPlanOveragesEnabled"""
    input: PracticeSetPlanOveragesEnabledInput!
  ): PracticeSetPlanOveragesEnabledPayload
  practiceSetPreferredProposalEditor(
    """Parameters for PracticeSetPreferredProposalEditor"""
    input: PracticeSetPreferredProposalEditorInput!
  ): PracticeSetPreferredProposalEditorPayload
  practiceSetPrincipal(
    """Parameters for PracticeSetPrincipal"""
    input: PracticeSetPrincipalInput!
  ): PracticeSetPrincipalPayload
  practiceSetTfaEffectiveFrom(
    """Parameters for PracticeSetTfaEffectiveFrom"""
    input: PracticeSetTfaEffectiveFromInput!
  ): PracticeSetTfaEffectiveFromPayload

  """Update payment surcharge settings on behalf of a practice"""
  practiceSurchargeUpdate(
    """Parameters for PracticeSurchargeUpdate"""
    input: PracticeSurchargeUpdateInput!
  ): PracticeSurchargeUpdatePayload
  practiceTrialRenew(
    """Parameters for PracticeTrialRenew"""
    input: PracticeTrialRenewInput!
  ): PracticeTrialRenewPayload

  """
  This should only be run by developer. A developer will use it to update
  payment method of a proposal's billable services and billing items.
  """
  proposalPaymentMethodAttach(
    """Parameters for ProposalPaymentMethodAttach"""
    input: ProposalPaymentMethodAttachInput!
  ): ProposalPaymentMethodAttachPayload
  proposalRenewalsImportCreate(
    """Parameters for ProposalRenewalsImportCreate"""
    input: ProposalRenewalsImportCreateInput!
  ): ProposalRenewalsImportCreatePayload

  """
  For marketing to set a proposal as publicly previewable so that anonymous users can preview what the proposal contains
  """
  proposalSetPreviewable(
    """Parameters for ProposalSetPreviewable"""
    input: ProposalSetPreviewableInput!
  ): ProposalSetPreviewablePayload
  quickbooksIntegrationProposalBulkCreateFromRecurringTransactions(
    """Parameters for ProposalBulkCreateFromRecurringTransactions"""
    input: ProposalBulkCreateFromRecurringTransactionsInput!
  ): ProposalBulkCreateFromRecurringTransactionsPayload
  quickbooksIntegrationProposalCreateFromRecurringTransaction(
    """Parameters for ProposalCreateFromQuickbooksRecurringTransaction"""
    input: ProposalCreateFromQuickbooksRecurringTransactionInput!
  ): ProposalCreateFromQuickbooksRecurringTransactionPayload
  referralCopyUpdate(
    """Parameters for ReferralCopyUpdate"""
    input: ReferralCopyUpdateInput!
  ): ReferralCopyUpdatePayload
  textileConvertLegacyTextile(
    """Parameters for TextileConvertLegacyTextile"""
    input: TextileConvertLegacyTextileInput!
  ): TextileConvertLegacyTextilePayload
  userDelete(
    """Parameters for UserDelete"""
    input: UserDeleteInput!
  ): UserDeletePayload
  userResetTfa(
    """Parameters for UserResetTfa"""
    input: UserResetTfaInput!
  ): UserResetTfaPayload
  userTokenGenerate(
    """Parameters for UserTokenGenerate"""
    input: UserTokenGenerateInput!
  ): UserTokenGeneratePayload
  userUpdate(
    """Parameters for UserUpdate"""
    input: UserUpdateInput!
  ): UserUpdatePayload
  xeroIntegrationProposalBulkCreateFromRepeatingInvoices(
    """Parameters for ProposalBulkCreateFromRepeatingInvoices"""
    input: ProposalBulkCreateFromRepeatingInvoicesInput!
  ): ProposalBulkCreateFromRepeatingInvoicesPayload
  xeroIntegrationProposalCreateFromRepeatingInvoice(
    """Parameters for ProposalCreateFromXeroRepeatingInvoice"""
    input: ProposalCreateFromXeroRepeatingInvoiceInput!
  ): ProposalCreateFromXeroRepeatingInvoicePayload
}

type NotificationsSettings {
  audits(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): AuditConnection
  notificationType: String!
  remindersRecurrenceRule: String
  state: String!
}

"""The connection type for NotificationsSettings."""
type NotificationsSettingsConnection {
  """A list of edges."""
  edges: [NotificationsSettingsEdge!]!

  """A list of nodes."""
  nodes: [NotificationsSettings!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type NotificationsSettingsEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: NotificationsSettings!
}

input NotificationsSettingsFilter {
  notificationType: String
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

"""Autogenerated input type of PaymentClawback"""
input PaymentClawbackInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The ID of the Payment"""
  paymentId: ID!
}

"""Autogenerated return type of PaymentClawback."""
type PaymentClawbackPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  invoice: ClientBillingInvoice
  payment: PaymentsPayment
}

type PaymentMethod {
  createdAt: DateTime!
  currency: Currency!
  expiryDate: Date
  gatewayId: String
  id: ID!
  isVerified: Boolean!
  name: String
  numberSuffix: String
  status: PaymentMethodStatus!
  type: PaymentMethodType
  updatedAt: DateTime!
}

type PaymentMethodFee {
  createdAt: DateTime
  creditCardBrand: String
  creditCardType: String
  expiresAt: DateTime
  feeAddition: Money!
  feeAmount: Money
  feeMaximum: Money
  feeMinimum: Money
  feePercentage: Percentage
  feeType: String!
  id: ID!
  paymentMethodCurrency: String!
  paymentMethodType: String!
  planTier: String
  reason: String
  tenantId: Int
  updatedAt: DateTime
}

"""The connection type for PaymentMethodFee."""
type PaymentMethodFeeConnection {
  """A list of edges."""
  edges: [PaymentMethodFeeEdge!]!

  """A list of nodes."""
  nodes: [PaymentMethodFee!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type PaymentMethodFeeEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: PaymentMethodFee!
}

enum PaymentMethodStatus {
  ACTIVE
  DELETED
}

enum PaymentMethodType {
  CREDIT_CARD
  BANK_ACCOUNT
}

"""Autogenerated input type of PaymentRefundApprove"""
input PaymentRefundApproveInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Refund we are approving"""
  id: ID!

  """The ID of the Practice we are approving the refund for"""
  practiceId: ID!
}

"""Autogenerated return type of PaymentRefundApprove."""
type PaymentRefundApprovePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  refund: PaymentsRefund!
}

"""Autogenerated input type of PaymentRefundDecline"""
input PaymentRefundDeclineInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Refund we are declining"""
  id: ID!

  """The ID of the Practice we are declining the refund for"""
  practiceId: ID!
}

"""Autogenerated return type of PaymentRefundDecline."""
type PaymentRefundDeclinePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  refund: PaymentsRefund!
}

"""Autogenerated input type of PaymentRefund"""
input PaymentRefundInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The ID of the Payment"""
  paymentId: ID!
}

"""Autogenerated return type of PaymentRefund."""
type PaymentRefundPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  invoice: ClientBillingInvoice
  payment: PaymentsPayment
}

"""Autogenerated input type of PaymentReverse"""
input PaymentReverseInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The ID of the Payment"""
  paymentId: ID!
}

"""Autogenerated return type of PaymentReverse."""
type PaymentReversePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  invoice: ClientBillingInvoice
  payment: PaymentsPayment
}

type PaymentsClawback {
  amount: Money!
  completedAt: DateTime
  createdAt: DateTime!
  externalId: String
  id: ID!
  message: String
  paymentMethod: PaymentMethod!
  startedAt: DateTime
  state: PaymentsClawbackState!
  updatedAt: DateTime!
}

"""The connection type for PaymentsClawback."""
type PaymentsClawbackConnection {
  """A list of edges."""
  edges: [PaymentsClawbackEdge!]!

  """A list of nodes."""
  nodes: [PaymentsClawback!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type PaymentsClawbackEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: PaymentsClawback!
}

enum PaymentsClawbackState {
  STARTED
  COMPLETED
  FAILED
}

type PaymentsCollection {
  amount: Money!

  """The client associated to this collection"""
  client: Client
  completedAt: DateTime
  createdAt: DateTime!
  dashboardUri: String
  externalId: String
  failedAt: DateTime
  id: ID!
  invoice: ClientBillingInvoice
  message: String
  paymentMethod: PaymentMethod!
  scheduledTime: DateTime
  startedAt: DateTime
  state: PaymentsCollectionState!
  updatedAt: DateTime!
}

"""The connection type for PaymentsCollection."""
type PaymentsCollectionConnection {
  """A list of edges."""
  edges: [PaymentsCollectionEdge!]!

  """A list of nodes."""
  nodes: [PaymentsCollection!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type PaymentsCollectionEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: PaymentsCollection!
}

enum PaymentsCollectionState {
  STARTED
  COMPLETED
  FAILED
}

type PaymentsDisbursal {
  amount: Money!
  availableOn: Date!
  externalId: String!
  feeAmount: Money!
  feeDescription: String!

  """Disbursal slug"""
  id: ID!
  payments(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PaymentsPaymentConnection
  payout: StripePayout
  startedAt: DateTime!
  state: PaymentsDisbursalStateEnum!
}

"""The connection type for PaymentsDisbursal."""
type PaymentsDisbursalConnection {
  """A list of edges."""
  edges: [PaymentsDisbursalEdge!]!

  """A list of nodes."""
  nodes: [PaymentsDisbursal!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type PaymentsDisbursalEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: PaymentsDisbursal!
}

input PaymentsDisbursalFilter {
  idEq: ID
  externalIdCont: String
}

enum PaymentsDisbursalStateEnum {
  STARTED
  COMPLETED
  FAILED
}

"""Additional expenses added to the price of a transaction"""
type PaymentsFee {
  """A amount per charge"""
  amount: Money

  """The description of the fee based on"""
  description: String
}

"""
Payments Settings onboarded preset, used to preset configurations such as payment fees and custom BACS
"""
enum PaymentsOnboardedPresetType {
  INTERNAL
  HIGH_VALUE
  SUPER_HIGH_VALUE
  BANK_ACCOUNT_PAYMENT_DISCOUNT
  PARTNERSHIP_TAX_ASSIST
  PARTNERSHIP_XEINADIN_GROUP
  PARTNERSHIP_CARBON_GROUP
  TWENTY_TWENTY_THREE_NO_FEES_THREE_MONTHS
}

type PaymentsPayment {
  activities(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ActivityLogConnection
  amount: Money!
  availableOn: Date
  canCollect: Boolean!
  clawbacks(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PaymentsClawbackConnection
  collections(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PaymentsCollectionConnection
  createdAt: DateTime!
  fee: PaymentsFee
  id: ID!
  invoice: ClientBillingInvoice

  """
  Payment disbursals associated with the payment, not a direct representation of PaymentsDisbursal type
  """
  paymentDisbursals(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PaymentsPaymentDisbursalConnection
  paymentMethod: PaymentMethod!
  reference: String!
  refunds(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: RefundsFilter
  ): PaymentsRefundConnection
  scheduledCollectionTime: DateTime
  state: PaymentsPaymentStateEnum!
  updatedAt: DateTime!
}

"""The connection type for PaymentsPayment."""
type PaymentsPaymentConnection {
  """A list of edges."""
  edges: [PaymentsPaymentEdge!]!

  """A list of nodes."""
  nodes: [PaymentsPayment!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type PaymentsPaymentDisbursal {
  externalId: String!

  """Disbursal slug"""
  id: ID!
  startedAt: DateTime!
  state: PaymentsDisbursalStateEnum!
}

"""The connection type for PaymentsPaymentDisbursal."""
type PaymentsPaymentDisbursalConnection {
  """A list of edges."""
  edges: [PaymentsPaymentDisbursalEdge!]!

  """A list of nodes."""
  nodes: [PaymentsPaymentDisbursal!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type PaymentsPaymentDisbursalEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: PaymentsPaymentDisbursal!
}

"""An edge in a connection."""
type PaymentsPaymentEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: PaymentsPayment!
}

enum PaymentsPaymentStateEnum {
  UNCOLLECTED
  COLLECTING
  COLLECTED
  REFUNDING
  REFUNDED
  DISBURSING
  DISBURSED
  CLAWING_BACK
  CANCELLED
}

type PaymentsRefund {
  amount: Money!
  completedAt: DateTime
  createdAt: DateTime!
  externalId: String
  id: ID!
  message: String
  payment: PaymentsPayment!
  paymentMethod: PaymentMethod!

  """Payment refund reason"""
  reason: String
  startedAt: DateTime
  state: PaymentsRefundState!
  updatedAt: DateTime!
}

"""The connection type for PaymentsRefund."""
type PaymentsRefundConnection {
  """A list of edges."""
  edges: [PaymentsRefundEdge!]!

  """A list of nodes."""
  nodes: [PaymentsRefund!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type PaymentsRefundEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: PaymentsRefund!
}

enum PaymentsRefundState {
  APPROVED
  PENDING
  DECLINED
  STARTED
  COMPLETED
  FAILED
  CANCELED
}

type PaymentsSettings {
  audits(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): AuditConnection

  """Whether this practice is collecting payments via credit card"""
  creditCardAccepted: Boolean!

  """Whether this practice is collecting payments via direct debit"""
  directDebitAccepted: Boolean!

  """Whether direct debit collections can be turned on for this practice"""
  directDebitSupported: Boolean!

  """
  Scheduled date disbursals will be disabled for this practice. Clears once a practice's disbursals have been disabled
  """
  disableDisbursalsAt: DateTime

  """Disbursals Disablement Linked Payment Collection"""
  disbursalsDisablementLinkedCollection: PaymentsCollection

  """Disbursals Disablement Type"""
  disbursalsDisablementType: DisbursalsDisablementType

  """Fraud Payment Threshold"""
  fraudPaymentThreshold: Money
  hasDisbursalAccount: Boolean!

  """Are collections enabled?"""
  isCollectionsEnabled: Boolean!

  """Are disbursals enabled?"""
  isDisbursalsEnabled: Boolean!

  """
  Whether surcharges are restricted to only the 'credit_card' surcharge category
  """
  isSurchargeCreditCardsOnly: Boolean!

  """
  Whether a practice can use surcharges to pass on payment fees to their clients
  """
  isSurchargeEnabled: Boolean!

  """Settings configuration applied to practice"""
  onboardedPreset: PaymentsOnboardedPresetType

  """
  Number of days a payment will be collected after an invoice for one-off payment is raised
  """
  onceOffTerms: Int!

  """The percentage fee discount applied to any payment fees incurred"""
  paymentFeeDiscount: Percentage

  """
  Whether this practice requires a valid payment method from a client when a proposal is accepted
  """
  paymentMethodRequired: Boolean!

  """
  Number of days a payment will be collected after an invoice for a recurring payment is raised
  """
  recurringTerms: Int!

  """Description of the most recent change to surcharge settings"""
  surchargeLastUpdateMessage: String

  """Rate at which applicable cards are surcharged"""
  surchargeRate: Percentage!
}

type Percentage {
  format: String!
  value: Decimal!
}

input PercentageInput {
  """Value as a percentage, e.g. 10%"""
  percentage: Float

  """Percentage as a value, e.g. 0.1"""
  value: Float
}

scalar PhoneNumber

type Plan {
  billingPeriod: PlanBillingPeriod!
  code: String!

  """
  If set, defines the active client limit for this practice overriding the default provided by their plan.
  """
  customActiveClientLimit: Int
  isEligible: Boolean!
  isLegacy: Boolean!
  maxClients: Int!
  name: String!
  overagesEnabled: Boolean!
  price: Money!
  tier: PlanNameEnum!
}

enum PlanBillingPeriod {
  """Billed monthly"""
  MONTHLY

  """Billed annually"""
  ANNUALLY
}

enum PlanNameEnum {
  PROPLUS
  BOOKKEEPER
  PRO
  CORE
  NONE
  TRIAL
  STARTER
  PROFESSIONAL
  SCALE

  """Legacy plan"""
  MARS

  """Legacy plan"""
  JUPITER

  """Legacy plan"""
  NEPTUNE

  """Legacy plan"""
  SATURN
}

"""Autogenerated input type of PracticDeleteArchivedClients"""
input PracticDeleteArchivedClientsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!
}

"""Autogenerated return type of PracticDeleteArchivedClients."""
type PracticDeleteArchivedClientsPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

type Practice {
  audits(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): AuditConnection
  billingCurrency: Currency!
  brandingTheme: BrandingTheme!
  bulkKickOffs(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: BulkKickOffFilter
  ): BulkKickOffConnection
  client(id: ID!): Client
  clients(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: ClientFilter
  ): ClientConnection

  """
  List of revenue brackets for cmi questions based on the current practice region
  """
  cmiRevenueBrackets: [RevenueBracket!]!
  countryCode: String
  createdAt: DateTime
  currencySymbol: String!
  customTemplates(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: CustomTemplateFilter
  ): CustomTemplateConnection
  customerSuccessMaturityIndex: CustomerSuccessMaturityIndexUnion
  customerSuccessMaturityIndices(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): CustomerSuccessMaturityIndexUnionConnection

  """
  Default service grouping for new proposals. This will be used unless otherwise changed within the proposal editor.
  
  """
  defaultBillingGroupedBy: BillingGroupedByType!
  disabled: Boolean!
  disabledReasonCategory: PracticeDisabledReasonCategory
  email: EmailAddress
  engagement(id: ID!): Engagement
  engagementLetters(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): CustomerSuccessEngagementLetterConnection
  engagements(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: EngagementFilter
  ): EngagementConnection
  feature(id: ID!): Feature
  featureFlag(id: String!): FeatureFlag!
  features: [Feature!]!
  id: ID!
  integrations(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: IntegrationFilter
  ): IntegrationConnection
  intent: PracticeIntentEnum!
  interchangeFees(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): InterchangeFeeConnection!
  internal: Boolean!
  ledgerName: String
  locale: String
  name: String
  notificationsSettings(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: NotificationsSettingsFilter
  ): NotificationsSettingsConnection!

  """Practice assigned payment gateways"""
  paymentGateways: [PracticePaymentGateway!]
  paymentMethodFees(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PaymentMethodFeeConnection
  paymentSettings: PaymentsSettings!
  paymentsDisbursals(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: PaymentsDisbursalFilter
  ): PaymentsDisbursalConnection
  phone: String
  plan: Plan
  preferredProposalEditor: ProposalEditor
  principal: User
  proposal(id: ID!): Proposal
  proposalTemplatePublishRegion: String

  """List of Quickbooks Recurring Transactions"""
  quickbooksRecurringTransactions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    recurringTransactionType: String
    nameContains: String
  ): QuickbooksRecurringTransactionConnection
  recurlyAccountUrl: URL
  referenceNumber: ID!

  """
  The referral copy published for a particular region.
                        Only applicable on special practices with 'proposal_template_publish_region' defined.
  """
  referralCopy: CustomerSuccessReferralCopy
  region: String
  renewalsImports(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: RenewalsImportFilter
  ): RenewalsImportConnection
  services(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: ServiceFilter
  ): ServiceTypeConnection!
  slug: String!
  stripeIntegrationAccount: StripeIntegrationAccount
  templates(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: TemplateFilter
  ): TemplateConnection
  tfaEffectiveFrom: Date
  timeZone: TimeZone!
  trialEndDate: Date
  twoFactorAuthRequired: Boolean!

  """Find a User by ID"""
  user(id: ID!): User
  users(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: UserFilter
  ): UserConnection

  """List of Xero Repeating Invoices"""
  xeroRepeatingInvoices(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    nameContains: String
    includeDeleted: Boolean
  ): XeroIntegrationRepeatingInvoiceConnection
}

enum PracticeBillingPlanFrequency {
  MONTHLY
  ANNUALLY
}

"""Autogenerated input type of practiceBillingSetSubscription"""
input practiceBillingSetSubscriptionInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!
  plan: setSubscriptionPracticeBillingPlanInput
}

"""Autogenerated return type of practiceBillingSetSubscription."""
type practiceBillingSetSubscriptionPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

"""The connection type for Practice."""
type PracticeConnection {
  """A list of edges."""
  edges: [PracticeEdge!]!

  """A list of nodes."""
  nodes: [Practice!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

enum PracticeDisabledReasonCategory {
  SUSPECT_FRAUD
  ADMIN_RESET
  ADMIN_ACCIDENTAL_TRIAL_EXTENSION
  CUSTOMER_ACCIDENTAL_CREATION
  CUSTOMER_REQUEST
  OTHER
}

"""Autogenerated input type of PracticeDisable"""
input PracticeDisableInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!
  cancelSubscription: Boolean
  reason: String!
  reasonCategory: PracticeDisabledReasonCategory!
}

"""Autogenerated return type of PracticeDisable."""
type PracticeDisablePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
  userErrors: [UserError!]
}

"""An edge in a connection."""
type PracticeEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Practice!
}

"""Autogenerated input type of PracticeEnable"""
input PracticeEnableInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!
}

"""Autogenerated return type of PracticeEnable."""
type PracticeEnablePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

"""Autogenerated input type of PracticeFeatureFlagEnable"""
input PracticeFeatureFlagEnableInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The "id" of the feature"""
  id: String!
}

"""Autogenerated return type of PracticeFeatureFlagEnable."""
type PracticeFeatureFlagEnablePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  featureFlag: FeatureFlag!
}

input PracticeFilter {
  nameCont: String
  idEq: String
  subscriptionStatusEq: SubscriptionStatus
}

enum PracticeIntentEnum {
  GROWTH
  PAYMENTS
  EFFICIENCY
  PROFIT
  UNKNOWN
}

"""Autogenerated input type of PracticeOffboardPayments"""
input PracticeOffboardPaymentsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!
}

"""Autogenerated return type of PracticeOffboardPayments."""
type PracticeOffboardPaymentsPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

"""Autogenerated input type of PracticeOnboardPayments"""
input PracticeOnboardPaymentsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The template configuration"""
  preset: PaymentsOnboardedPresetType!
}

"""Autogenerated return type of PracticeOnboardPayments."""
type PracticeOnboardPaymentsPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

type PracticePaymentGateway {
  """Flag to indicate if gateway is active for a practice"""
  active: Boolean!
  gatewayId: String!
  processorId: String!
}

"""Autogenerated input type of PracticeSetCustomActiveClientLimit"""
input PracticeSetCustomActiveClientLimitInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice to update"""
  practiceId: ID!

  """New active client limit"""
  limit: Int
}

"""Autogenerated return type of PracticeSetCustomActiveClientLimit."""
type PracticeSetCustomActiveClientLimitPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

"""Autogenerated input type of PracticeSetFraudPaymentThreshold"""
input PracticeSetFraudPaymentThresholdInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice to set fraud payment threshold for"""
  practiceId: ID!

  """Fraud Payment Threshold"""
  fraudPaymentThreshold: MoneyInput!
}

"""Autogenerated return type of PracticeSetFraudPaymentThreshold."""
type PracticeSetFraudPaymentThresholdPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

"""Autogenerated input type of PracticeSetPlanOveragesEnabled"""
input PracticeSetPlanOveragesEnabledInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  id: ID!

  """Whether or not overages are to be enabled"""
  overagesEnabled: Boolean!
}

"""Autogenerated return type of PracticeSetPlanOveragesEnabled."""
type PracticeSetPlanOveragesEnabledPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

"""Autogenerated input type of PracticeSetPreferredProposalEditor"""
input PracticeSetPreferredProposalEditorInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The preferred proposal editor. Null means no preference."""
  preferredProposalEditor: ProposalEditor
}

"""Autogenerated return type of PracticeSetPreferredProposalEditor."""
type PracticeSetPreferredProposalEditorPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice!
}

"""Autogenerated input type of PracticeSetPrincipal"""
input PracticeSetPrincipalInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the User being set as new Principal"""
  userId: ID!

  """The ID of the Practice"""
  practiceId: ID!
}

"""Autogenerated return type of PracticeSetPrincipal."""
type PracticeSetPrincipalPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
  principal: User
}

"""Autogenerated input type of PracticeSetTfaEffectiveFrom"""
input PracticeSetTfaEffectiveFromInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  id: ID!

  """
  The effective date (ISO Formatted) of requiring two factor auth for all practice users 
  """
  date: Date!
}

"""Autogenerated return type of PracticeSetTfaEffectiveFrom."""
type PracticeSetTfaEffectiveFromPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

"""Autogenerated input type of PracticeSurchargeUpdate"""
input PracticeSurchargeUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The slug of the practice to have its surcharge settings updated"""
  practiceId: ID!

  """Rate at which applicable cards are surcharged"""
  surchargeRate: PercentageInput!

  """
  Whether surcharges are restricted to only the 'credit_card' surcharge category
  """
  isSurchargeCreditCardsOnly: Boolean!
}

"""Autogenerated return type of PracticeSurchargeUpdate."""
type PracticeSurchargeUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice!
}

"""Autogenerated input type of PracticeTrialRenew"""
input PracticeTrialRenewInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """ISO formatted date"""
  trialEndDate: Date!
}

"""Autogenerated return type of PracticeTrialRenew."""
type PracticeTrialRenewPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
  userErrors: [UserError!]
}

type Proposal {
  """The client associated with the proposal (optional)"""
  client: Client

  """Slug of the source (e.g. template, proposal) of this proposal"""
  createdFrom: String

  """Reference number for the proposal (eg. PROP-0001)"""
  displayReferenceNumber: String!
  id: ID!

  """Checks to see if we can make updates to this proposal"""
  isEditable: Boolean!

  """The name of the proposal"""
  name: String!

  """The URL that points to the uploaded file."""
  pdfUrl: URL!

  """If true, the proposal can be previewed while in new or draft state"""
  publiclyPreviewable: Boolean!

  """The mapped recurring transaction (if present)"""
  quickbooksRecurringTransaction: QuickbooksRecurringTransaction

  """Signatories for this proposal"""
  signatories(filter: SignatoryFilter): [ProposalSignatory!]!

  """The proposal state"""
  state: ProposalState!
  token: String!

  """The mapped repeating invoice (if present)"""
  xeroRepeatingInvoice: XeroIntegrationRepeatingInvoice
}

"""
Autogenerated input type of ProposalBulkCreateFromRecurringTransactions
"""
input ProposalBulkCreateFromRecurringTransactionsInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """Type of Recurring Transaction"""
  type: String
}

"""
Autogenerated return type of ProposalBulkCreateFromRecurringTransactions.
"""
type ProposalBulkCreateFromRecurringTransactionsPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

"""Autogenerated input type of ProposalBulkCreateFromRepeatingInvoices"""
input ProposalBulkCreateFromRepeatingInvoicesInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!
}

"""Autogenerated return type of ProposalBulkCreateFromRepeatingInvoices."""
type ProposalBulkCreateFromRepeatingInvoicesPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  practice: Practice
}

"""The connection type for Proposal."""
type ProposalConnection {
  """A list of edges."""
  edges: [ProposalEdge!]!

  """A list of nodes."""
  nodes: [Proposal!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""
Autogenerated input type of ProposalCreateFromQuickbooksRecurringTransaction
"""
input ProposalCreateFromQuickbooksRecurringTransactionInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The ID/Slug of the recurring transaction"""
  recurringTransactionId: ID!
}

"""
Autogenerated return type of ProposalCreateFromQuickbooksRecurringTransaction.
"""
type ProposalCreateFromQuickbooksRecurringTransactionPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""Autogenerated input type of ProposalCreateFromXeroRepeatingInvoice"""
input ProposalCreateFromXeroRepeatingInvoiceInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The ID/Slug of the repeating invoice"""
  repeatingInvoiceId: ID!
}

"""Autogenerated return type of ProposalCreateFromXeroRepeatingInvoice."""
type ProposalCreateFromXeroRepeatingInvoicePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

"""An edge in a connection."""
type ProposalEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Proposal!
}

enum ProposalEditor {
  NPE
  CPE
}

type ProposalEditorCustomTemplate {
  appName: String
  audits(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): AuditConnection
  authorEntity: String
  authorLogoUrl: String
  authorName: String
  deletedAt: DateTime
  description: String!
  id: ID!
  logoUrl: String
  longDescription: String
  name: String!
  publishComment: String
  publishedAt: DateTime

  """Publisher's admin user"""
  publisher: AdminUser
  reference: String
  sourceName: String
  sourceType: CustomTemplateSourceType!
  templateData: JSON!
  templateYaml: String!
  updatedAt: DateTime!
  visibility: CustomTemplateVisibilityState!
}

input ProposalFilter {
  stateEq: ProposalState
  nameCont: String
}

"""Autogenerated input type of ProposalPaymentMethodAttach"""
input ProposalPaymentMethodAttachInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The ID of the NPE Proposal"""
  proposalId: ID!

  """The ID of the Payment Method"""
  paymentMethodId: ID!
}

"""Autogenerated return type of ProposalPaymentMethodAttach."""
type ProposalPaymentMethodAttachPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

type ProposalRenewalsImport {
  createdAt: DateTime!
  errors: [String!]
  file: Filestack!

  """The ID for this import"""
  id: ID
}

"""Autogenerated input type of ProposalRenewalsImportCreate"""
input ProposalRenewalsImportCreateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The structure referring to the Filestack file"""
  importFile: FilestackInput!
}

"""Autogenerated return type of ProposalRenewalsImportCreate."""
type ProposalRenewalsImportCreatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposalRenewalsImport: ProposalRenewalsImport
}

"""Autogenerated input type of ProposalSetPreviewable"""
input ProposalSetPreviewableInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the Practice"""
  practiceId: ID!

  """The ID of the NPE Proposal"""
  proposalId: ID!

  """The value of the publicly previewable flag"""
  publiclyPreviewable: Boolean!
}

"""Autogenerated return type of ProposalSetPreviewable."""
type ProposalSetPreviewablePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  proposal: Proposal
}

type ProposalSignatory {
  id: ID!

  """Portal proposal url"""
  proposalUrl: URL!
  role: SignatoryRoleEnum!
}

enum ProposalState {
  NEW
  DRAFT
  LOST
  ARCHIVED
  AWAITING_ACCEPTANCE
  ACCEPTED
  COMPLETED
}

type Query {
  client(id: ID!): Client
  clients(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: ClientFilter
  ): ClientConnection
  codeVersion: String!
  currentUser: AdminUser!
  customTemplate(id: ID!): ProposalEditorCustomTemplate
  customTemplates(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: CustomTemplateFilter
  ): CustomTemplateConnection
  engagement(
    """UUID or ID of engagement"""
    id: ID!
  ): Engagement
  environment: String!

  """Client Billing Invoice"""
  invoice(id: ID!): ClientBillingInvoice
  paymentsDisbursal(id: ID!): PaymentsDisbursal
  paymentsPayment(id: ID!): PaymentsPayment
  paymentsPaymentCollection(id: ID!): PaymentsCollection
  paymentsRefund(id: ID!): PaymentsRefund
  payout(
    """Payout's id in Stripe"""
    stripeId: ID!
  ): StripePayout
  practice(id: ID!): Practice!
  practices(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: PracticeFilter
  ): PracticeConnection!

  """Returns a Ignition object based on a related external Stripe object ID"""
  stripeIdSearch(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """The external Stripe ID of the object, e.g. 'pi_*', 'acct_*'"""
    stripeId: String!
  ): StripeIdSearchUnionConnection

  """Find a User by UUID"""
  user(id: ID!): User
  users(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    filter: UserFilter
  ): UserConnection!
}

type QuickbooksIntegrationLine {
  """Line amount"""
  amount: Money!

  """Description of the line"""
  description: String

  """Internal slug of the recuring transaction line"""
  id: ID!

  """Name of associated item (if present)"""
  itemName: String

  """Line number"""
  lineNum: Int!

  """Quantity"""
  quantity: String

  """Unit price"""
  unitPrice: Money!
}

type QuickbooksRecurringTransaction {
  """Name of the Customer associated with the recurring transaction"""
  customerName: String

  """When do we finish invoicing (optional)"""
  endDate: Date

  """Internal slug of the recurring transaction"""
  id: ID!

  """Interval type"""
  intervalType: String

  """List of Quickbooks Recurring Transaction Lines"""
  lines: [QuickbooksIntegrationLine!]

  """Max occurences (optional)"""
  maxOccurences: Int

  """When is the next transaction being generated"""
  nextDate: Date

  """The interval based on the interval type."""
  numInterval: Int

  """Mapped Proposal"""
  proposal: Proposal

  """External Quickbooks ID of the recurring transaction"""
  quickbooksId: String!

  """Automated, Reminded or Unscheduled"""
  recurType: String

  """Name of the Recurring Transaction"""
  recurringTemplateName: String

  """Total amount"""
  totalAmount: Money!

  """
  Type of Recurring Transaction (Bill, Deposit, Invoice, RefundReceipt, SalesReceipt, Transfer etc)
  """
  type: String!
}

"""The connection type for QuickbooksRecurringTransaction."""
type QuickbooksRecurringTransactionConnection {
  """A list of edges."""
  edges: [QuickbooksRecurringTransactionEdge!]!

  """A list of nodes."""
  nodes: [QuickbooksRecurringTransaction!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type QuickbooksRecurringTransactionEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: QuickbooksRecurringTransaction!
}

type RecipientGroup {
  audits(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): AuditConnection
  emailAddresses: [EmailAddress!]!
  name: String!
}

"""The connection type for RecipientGroup."""
type RecipientGroupConnection {
  """A list of edges."""
  edges: [RecipientGroupEdge]

  """A list of nodes."""
  nodes: [RecipientGroup]

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type RecipientGroupEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: RecipientGroup
}

input RecipientGroupFilter {
  name: String
}

"""Autogenerated input type of ReferralCopyUpdate"""
input ReferralCopyUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  title: String!
  description: String!
  practiceId: ID!
}

"""Autogenerated return type of ReferralCopyUpdate."""
type ReferralCopyUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  referralCopy: CustomerSuccessReferralCopy!
}

input RefundsFilter {
  state: PaymentsRefundState
}

type RenewalsImport {
  """When the import file was uploaded"""
  createdAt: DateTime!

  """Validation errors"""
  errors: [String!]

  """Filestack reference and details"""
  file: Filestack!

  """The ID for this Renewals import"""
  id: ID!
  state: RenewalsImportState!

  """Type of Renewals import"""
  type: RenewalsImportType!
}

"""The connection type for RenewalsImport."""
type RenewalsImportConnection {
  """A list of edges."""
  edges: [RenewalsImportEdge!]!

  """A list of nodes."""
  nodes: [RenewalsImport!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type RenewalsImportEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: RenewalsImport!
}

input RenewalsImportFilter {
  stateIn: [RenewalsImportState!]
  fileTypeEq: RenewalsImportType
}

enum RenewalsImportState {
  PENDING
  FAILED
  VALIDATED
  IMPORTED
}

enum RenewalsImportType {
  CLIENTS
}

"""An uploaded image which may be dynamically resized."""
type ResizeableImage {
  """The filename of the uploaded image."""
  filename: String!

  """The mimetype of the uploaded, if available."""
  mimetype: String

  """The size of the uploaded image in bytes, if available."""
  size: Int!

  """The public URL of the uploaded image."""
  url(
    """Width (in px)"""
    width: Int

    """Height (in px)"""
    height: Int

    """
    If height/width provided, how should the image be fit into the new dimensions.
    """
    fit: ResizeableImageFit
  ): URL!
}

enum ResizeableImageFit {
  """
  Preserve the aspect ratio, resize the image to be as large as possible while
  ensuring its dimensions are less than or equal to both those specified.
  """
  CLIP

  """
  Preserve the aspect ratio, ensure the image covers both provided dimensions by clipping/cropping to fit.
  """
  CROP

  """
  Do not enlarge if the dimensions of the provided image are already less than the specified width or height.
  """
  SCALE

  """
  Ignore the aspect ratio of the provided image and stretch to both provided dimensions.
  """
  MAX
}

type RevenueBracket {
  label: String!
  value: MaturityIndexRevenueBracketValueEnum!
}

input ServiceFilter {
  nameCont: String
  activeEngaged: Boolean
  recurringEngaged: Boolean
}

type ServiceType {
  id: ID!
  name: String!

  """The slug of the Service"""
  slug: ID!
}

"""The connection type for ServiceType."""
type ServiceTypeConnection {
  """A list of edges."""
  edges: [ServiceTypeEdge!]!

  """A list of nodes."""
  nodes: [ServiceType!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type ServiceTypeEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: ServiceType!
}

enum SetSubscriptionPlanNameEnums {
  CORE
  PRO
  PROPLUS
  BOOKKEEPER
}

input setSubscriptionPracticeBillingPlanInput {
  planName: SetSubscriptionPlanNameEnums!
  frequency: PracticeBillingPlanFrequency!
}

input SignatoryFilter {
  role: SignatoryRoleEnum
}

enum SignatoryRoleEnum {
  PRIMARY
  SECONDARY
}

enum StaffCount {
  """with a team of 50+ staff"""
  FIFTY_PLUS

  """with a team of 21-50 staff"""
  TWENTY_ONE_TO_FIFTY

  """with a team of 11-20 staff"""
  ELEVEN_TO_TWENTY

  """with a team of 6-10 staff"""
  SIX_TO_TEN

  """with a team of 4-5 staff"""
  FOUR_TO_FIVE

  """with a team of 1-3 staff"""
  ONE_TO_THREE

  """as a sole trader"""
  SOLE
}

type StripeCharge {
  amount: Money!
  collection: PaymentsCollection
  dashboardUri: URL!
  id: ID!
  reason: String
  status: String!
  stripeId: ID!
}

"""The connection type for StripeCharge."""
type StripeChargeConnection {
  """A list of edges."""
  edges: [StripeChargeEdge!]!

  """A list of nodes."""
  nodes: [StripeCharge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type StripeChargeEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: StripeCharge!
}

"""Possible result type of a stripe ID lookup"""
union StripeIdSearchUnion = Client | ClientBillingInvoice | PaymentsDisbursal | Practice

"""The connection type for StripeIdSearchUnion."""
type StripeIdSearchUnionConnection {
  """A list of edges."""
  edges: [StripeIdSearchUnionEdge]

  """A list of nodes."""
  nodes: [StripeIdSearchUnion]

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type StripeIdSearchUnionEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: StripeIdSearchUnion
}

type StripeIntegrationAccount {
  bacsDebitSun: BacsDebitSunType
  dashboardUri: URL!
  id: ID!
  stripeId: String!
}

type StripePayout {
  account: StripeIntegrationAccount!
  amount: Money!
  availableOn: DateTime
  charges(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): StripeChargeConnection
  dashboardUri: URL!
  disbursal: PaymentsDisbursal
  id: ID!
  paidAt: DateTime
  stripeId: ID!
}

enum SubscriptionStatus {
  SUBSCRIBED
  TRIAL
  EXPIRED
}

type Template {
  """Content of the template"""
  content: String

  """Description of the template"""
  description: String

  """The slug for this template"""
  id: ID!

  """Is the template the default template"""
  isDefault: Boolean!

  """User's name of the template"""
  name: String!

  """Subject text of the template"""
  subject: String

  """System's name of the template"""
  systemName: String

  """Summary of tags used in the Content of this template"""
  tagsUsed: String

  """Type of the template"""
  templateType: String!

  """Previous versions of the template"""
  versions: [TemplateVersion!]
}

"""The connection type for Template."""
type TemplateConnection {
  """A list of edges."""
  edges: [TemplateEdge!]!

  """A list of nodes."""
  nodes: [Template!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type TemplateEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Template!
}

input TemplateFilter {
  templateTypeIn: [TemplateType!]
  templateTypeEq: TemplateType
}

enum TemplateType {
  SYSTEM
  MESSAGE
  EMAIL
  ENGAGEMENT
}

type TemplateVersion {
  """Content of this template version"""
  content: String

  """Date this template version was saved"""
  date: DateTime!

  """The ID of this template version"""
  id: ID!

  """Sequence number of this template version"""
  number: ID!

  """Summary of tags used in the Content of this template version"""
  tagsUsed: String
}

"""Autogenerated input type of TextileConvertLegacyTextile"""
input TextileConvertLegacyTextileInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Legacy Textile (with Liquid)"""
  legacyTextile: String!
}

"""Autogenerated return type of TextileConvertLegacyTextile."""
type TextileConvertLegacyTextilePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  html: String!
}

"""A representation of a time zone."""
type TimeZone {
  """The standard ICANN tz database code (e.g. 'America/New_York')"""
  code: String!

  """
  The friendly (Rails compatible) time zone name (e.g. 'Eastern Time (US & Canada)')
  """
  name: String!

  """Formatted UTC offset."""
  utcOffset: String!

  """The UTC offset in seconds."""
  utcOffsetInSeconds: Int!
}

type Token {
  accessToken: String!
  client: ID!
  uid: String!
}

enum TwoFactorAuthMethod {
  AUTH_APP
  SMS
}

scalar URL

type User {
  active: Boolean!
  audits(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): AuditConnection
  avatarUrl: URL
  createdAt: DateTime!

  """Time stamp of the user's current/ most recent sign in"""
  currentSignInAt: DateTime

  """IP address of the user's current/ most recent sign in"""
  currentSignInIp: IpAddress
  emailAddress: EmailAddress!
  fullName: String
  id: ID!
  importedId: ID
  invitationAcceptedAt: DateTime
  invitationSentAt: DateTime
  isPrincipal: Boolean!
  jobTitle: String

  """Time stamp of the user's previous sign in"""
  lastSignInAt: DateTime

  """IP address of the user's previous sign in"""
  lastSignInIp: IpAddress
  practice: Practice!
  role: String
  signInCount: Int!
  twoFactorAuthEnabled: Boolean!
  twoFactorAuthMethod: TwoFactorAuthMethod
  twoFactorAuthMobile: PhoneNumber
  updatedAt: DateTime!
}

"""The connection type for User."""
type UserConnection {
  """A list of edges."""
  edges: [UserEdge!]!

  """A list of nodes."""
  nodes: [User!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Autogenerated input type of UserDelete"""
input UserDeleteInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the User"""
  userId: ID!

  """The ID of the Practice"""
  practiceId: ID!
}

"""Autogenerated return type of UserDelete."""
type UserDeletePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  user: User
  userErrors: [UserError!]
}

"""An edge in a connection."""
type UserEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: User!
}

type UserError {
  """Path to the input field which caused the error"""
  field: [String!]

  """The error message"""
  message: String!
}

input UserFilter {
  nameCont: String
  emailCont: String
}

input UserInputType {
  id: ID
  emailAddress: EmailAddress
}

"""Autogenerated input type of UserResetTfa"""
input UserResetTfaInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the User"""
  userId: ID!

  """The ID of the Practice"""
  practiceId: ID!
}

"""Autogenerated return type of UserResetTfa."""
type UserResetTfaPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  user: User
}

"""Autogenerated input type of UserTokenGenerate"""
input UserTokenGenerateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """The ID of the User"""
  id: ID!
}

"""Autogenerated return type of UserTokenGenerate."""
type UserTokenGeneratePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  token: Token!
}

"""Autogenerated input type of UserUpdate"""
input UserUpdateInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  user: UserInputType!

  """The ID of the Practice"""
  practiceId: ID!
}

"""Autogenerated return type of UserUpdate."""
type UserUpdatePayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  user: User
  userErrors: [UserError!]
}

type XeroIntegrationLineItem {
  """Whether or not the repeating invoice line item was deleted."""
  deleted: Boolean

  """Description of the line item"""
  description: String!

  """Discount amount"""
  discountAmount: Money!

  """Discount rate"""
  discountRate: Float

  """Internal slug of the repeating invoice line item"""
  id: ID!

  """Item code"""
  itemCode: String

  """Name of associated item (if present)"""
  itemName: String

  """Line amount"""
  lineAmount: Money!

  """Quantity"""
  quantity: Float

  """Tax amount"""
  taxAmount: Money!

  """Tax Type"""
  taxType: String

  """Unit amount"""
  unitAmount: Money!
}

type XeroIntegrationRepeatingInvoice {
  """Name of the Contact associated with the repeating invoice"""
  contactName: String

  """Whether or not the repeating invoice was deleted."""
  deleted: Boolean

  """When do we finish invoicing (optional)"""
  endDate: Date

  """Internal slug of the repeating invoice"""
  id: ID!

  """List of Xero Repeating Invoice Line Items"""
  lineItems: [XeroIntegrationLineItem!]

  """When is the next invoice being generated"""
  nextScheduledDate: Date!

  """Weekly or monthly frequency"""
  period: Int!

  """Mapped Proposal"""
  proposal: Proposal

  """Total cost"""
  total: Money!

  """WEEKLY or MONTHLY"""
  unit: String!

  """Customer added string to refer to the repeating invoice"""
  xeroReference: String

  """External Xero ID of the repeating invoice"""
  xeroRepeatingInvoiceId: String!
}

"""The connection type for XeroIntegrationRepeatingInvoice."""
type XeroIntegrationRepeatingInvoiceConnection {
  """A list of edges."""
  edges: [XeroIntegrationRepeatingInvoiceEdge!]!

  """A list of nodes."""
  nodes: [XeroIntegrationRepeatingInvoice!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type XeroIntegrationRepeatingInvoiceEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: XeroIntegrationRepeatingInvoice!
}

