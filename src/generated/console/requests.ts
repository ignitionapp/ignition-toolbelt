/* eslint-disable */
/* AUTO-GENERATED FILE. DO NOT EDIT MANUALLY. */
import type * as Types from './types';

import type { GraphQLClient } from 'graphql-request';
import type * as Dom from 'graphql-request/src/types.dom';
import gql from 'graphql-tag';

export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<
  T extends { [key: string]: unknown },
  K extends keyof T
> = { [_ in K]?: never };
export type Incremental<T> =
  | T
  | {
      [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never;
    };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string };
  String: { input: string; output: string };
  Boolean: { input: boolean; output: boolean };
  Int: { input: number; output: number };
  Float: { input: number; output: number };
  /** Represents non-fractional signed whole numeric values. */
  BigInt: { input: any; output: any };
  /** ISO8601 formatted date (yyyy-mm-dd) */
  Date: { input: any; output: any };
  DateTime: { input: any; output: any };
  Decimal: { input: any; output: any };
  EmailAddress: { input: any; output: any };
  IpAddress: { input: any; output: any };
  /** Represents untyped JSON */
  JSON: { input: any; output: any };
  PhoneNumber: { input: any; output: any };
  URL: { input: any; output: any };
};

/** Autogenerated input type of AccountBacsDebitSun */
export type AccountBacsDebitSunInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  descriptor: Scalars['String']['input'];
  practiceId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of AccountBacsDebitSun. */
export type AccountBacsDebitSunPayload = {
  __typename: 'AccountBacsDebitSunPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

export type ActivityLog = {
  __typename: 'ActivityLog';
  additionalInfo?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  level: ActivityLogLevel;
  message: Scalars['String']['output'];
  relationId: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for ActivityLog. */
export type ActivityLogConnection = {
  __typename: 'ActivityLogConnection';
  /** A list of edges. */
  edges: Array<ActivityLogEdge>;
  /** A list of nodes. */
  nodes: Array<ActivityLog>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ActivityLogEdge = {
  __typename: 'ActivityLogEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: ActivityLog;
};

export enum ActivityLogLevel {
  ERROR = 'ERROR',
  INFO = 'INFO',
  SUCCESS = 'SUCCESS',
  WARNING = 'WARNING',
}

export type AdminUser = {
  __typename: 'AdminUser';
  createdAt: Scalars['DateTime']['output'];
  email: Scalars['EmailAddress']['output'];
  id: Scalars['ID']['output'];
  roles?: Maybe<Array<Scalars['String']['output']>>;
  updatedAt: Scalars['DateTime']['output'];
};

/** Autogenerated input type of AppClientsExport */
export type AppClientsExportInput = {
  /** The name of the app to filter on */
  appName?: InputMaybe<AppNameEnum>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of AppClientsExport. */
export type AppClientsExportPayload = {
  __typename: 'AppClientsExportPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  export: Export;
};

export enum AppNameEnum {
  QUICKBOOKS = 'QUICKBOOKS',
  XERO = 'XERO',
  XPM = 'XPM',
}

export type Audit = {
  __typename: 'Audit';
  action: AuditAction;
  auditedChanges: Scalars['JSON']['output'];
  comment?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  referenceNumber: Scalars['ID']['output'];
  user?: Maybe<AuditUserUnion>;
  version: Scalars['Int']['output'];
};

export enum AuditAction {
  CREATE = 'CREATE',
  DELETE = 'DELETE',
  UPDATE = 'UPDATE',
}

/** The connection type for Audit. */
export type AuditConnection = {
  __typename: 'AuditConnection';
  /** A list of edges. */
  edges: Array<AuditEdge>;
  /** A list of nodes. */
  nodes: Array<Audit>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AuditEdge = {
  __typename: 'AuditEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Audit;
};

/** Possible user type of audits */
export type AuditUserUnion = AdminUser | User;

export enum Author {
  /** admin */
  ADMIN = 'ADMIN',
  /** customer */
  CUSTOMER = 'CUSTOMER',
  /** ledger */
  LEDGER = 'LEDGER',
}

export type BackgroundJob = {
  __typename: 'BackgroundJob';
  /** sidekiq background job id */
  id: Scalars['String']['output'];
  /** timestamp of when the job was queued */
  queuedAt: Scalars['DateTime']['output'];
};

export type BacsDebitSunType = {
  __typename: 'BacsDebitSunType';
  descriptor: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  state: Scalars['String']['output'];
};

export enum BillingGroupedByType {
  CLIENT = 'CLIENT',
  PROJECT = 'PROJECT',
  PROPOSAL = 'PROPOSAL',
}

export type BrandingTheme = {
  __typename: 'BrandingTheme';
  colour: Scalars['String']['output'];
  colourHex: Scalars['String']['output'];
  defaultBrochure?: Maybe<Filestack>;
  /** @deprecated Use default_brochure { url } instead. */
  defaultBrochureUrl?: Maybe<Scalars['URL']['output']>;
  id: Scalars['ID']['output'];
  /** Tells you if the returned logo is the Ignition provided default. */
  isDefaultLogo: Scalars['Boolean']['output'];
  logo: ResizeableImage;
  /** @deprecated Use logo { url } instead. */
  logoUrl: Scalars['URL']['output'];
};

export type BulkKickOff = {
  __typename: 'BulkKickOff';
  /** Admin user */
  adminUser: AdminUser;
  bulkKickOffType: BulkKickOffType;
  createdAt: Scalars['DateTime']['output'];
  errors?: Maybe<Array<Scalars['String']['output']>>;
  file: Filestack;
  /** The slug for this BKO record */
  id: Scalars['ID']['output'];
  /** The number of proposals associated to this BKO */
  proposalCount: Scalars['Int']['output'];
  /** The progress of sending proposals */
  sendProgress: BulkKickOffSendProgress;
  status: BulkKickOffStatus;
};

/** The connection type for BulkKickOff. */
export type BulkKickOffConnection = {
  __typename: 'BulkKickOffConnection';
  /** A list of edges. */
  edges: Array<BulkKickOffEdge>;
  /** A list of nodes. */
  nodes: Array<BulkKickOff>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of BulkKickOffCreate */
export type BulkKickOffCreateInput = {
  bulkKickOffType: BulkKickOffType;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  importFile: FilestackInput;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of BulkKickOffCreate. */
export type BulkKickOffCreatePayload = {
  __typename: 'BulkKickOffCreatePayload';
  bulkKickOff?: Maybe<BulkKickOff>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  userErrors?: Maybe<Array<UserError>>;
};

/** An edge in a connection. */
export type BulkKickOffEdge = {
  __typename: 'BulkKickOffEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: BulkKickOff;
};

export type BulkKickOffFilter = {
  fileTypeEq?: InputMaybe<BulkKickOffType>;
  statusIn?: InputMaybe<Array<BulkKickOffStatus>>;
};

export type BulkKickOffSendProgress = {
  __typename: 'BulkKickOffSendProgress';
  lastNpeSent?: Maybe<Scalars['DateTime']['output']>;
  numberNpe: Scalars['Int']['output'];
  numberNpeAccepted: Scalars['Int']['output'];
  numberNpeArchived: Scalars['Int']['output'];
  numberNpeLost: Scalars['Int']['output'];
  numberNpePending: Scalars['Int']['output'];
  numberNpeSent: Scalars['Int']['output'];
};

export enum BulkKickOffStatus {
  ARCHIVED = 'ARCHIVED',
  FAILED = 'FAILED',
  IMPORTED = 'IMPORTED',
  PENDING = 'PENDING',
  SENT_PROPOSALS = 'SENT_PROPOSALS',
  VALIDATED = 'VALIDATED',
}

export enum BulkKickOffType {
  CLIENTS = 'CLIENTS',
  ENGAGEMENT_MAPPING = 'ENGAGEMENT_MAPPING',
  PROPOSAL_MAPPING = 'PROPOSAL_MAPPING',
}

/** Autogenerated input type of BulkKickoffArchiveProposals */
export type BulkKickoffArchiveProposalsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The slug of the bulk kickoff */
  id: Scalars['ID']['input'];
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of BulkKickoffArchiveProposals. */
export type BulkKickoffArchiveProposalsPayload = {
  __typename: 'BulkKickoffArchiveProposalsPayload';
  bulkKickOff?: Maybe<BulkKickOff>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of BulkKickoffSendProposals */
export type BulkKickoffSendProposalsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The slug of the bulk kickoff */
  id: Scalars['ID']['input'];
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  /** Send email to client */
  sendToClient?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of BulkKickoffSendProposals. */
export type BulkKickoffSendProposalsPayload = {
  __typename: 'BulkKickoffSendProposalsPayload';
  bulkKickOff?: Maybe<BulkKickOff>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CancelScheduledDisbursalsDisablement */
export type CancelScheduledDisbursalsDisablementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice to cancel scheduled disbursals disablement for */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of CancelScheduledDisbursalsDisablement. */
export type CancelScheduledDisbursalsDisablementPayload = {
  __typename: 'CancelScheduledDisbursalsDisablementPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

export type Client = {
  __typename: 'Client';
  audits?: Maybe<AuditConnection>;
  businessStructure?: Maybe<Scalars['String']['output']>;
  canArchive: Scalars['Boolean']['output'];
  cbsEnabled: Scalars['Boolean']['output'];
  companyNumber?: Maybe<Scalars['String']['output']>;
  contacts: ContactConnection;
  createdAt: Scalars['DateTime']['output'];
  dashboardUri?: Maybe<Scalars['String']['output']>;
  deletedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Reference number for the client (eg. CLI-0001) */
  displayReferenceNumber: Scalars['String']['output'];
  /** @deprecated emailAddress is no longer available on the client. Use the default contact email instead. */
  emailAddress?: Maybe<Scalars['EmailAddress']['output']>;
  engagements?: Maybe<EngagementConnection>;
  faxNumber?: Maybe<Scalars['PhoneNumber']['output']>;
  gstRegistered?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  invoices?: Maybe<ClientBillingInvoiceConnection>;
  /** Is revenue from this client excluded from the dashboard and other reports? */
  isExcludedFromReports: Scalars['Boolean']['output'];
  /** Whether the practice applies surcharges to pass on payment fees to this client */
  isSurchargeEnabled: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  notes?: Maybe<Scalars['String']['output']>;
  notificationsSettings: NotificationsSettingsConnection;
  paymentMethods?: Maybe<Array<PaymentMethod>>;
  phoneNumber?: Maybe<Scalars['PhoneNumber']['output']>;
  /** Indicates if the client is a placeholder client for public previews */
  placeholder: Scalars['Boolean']['output'];
  practice: Practice;
  proposals?: Maybe<ProposalConnection>;
  recipientGroup: RecipientGroupConnection;
  state: ClientState;
  type: ClientType;
  updatedAt: Scalars['DateTime']['output'];
  websiteUrl?: Maybe<Scalars['URL']['output']>;
};

export type ClientAuditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ClientContactsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ClientEngagementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EngagementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ClientInvoicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ClientBillingInvoiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ClientNotificationsSettingsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NotificationsSettingsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ClientProposalsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ProposalFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ClientRecipientGroupArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<RecipientGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of ClientAgreedServicesExport */
export type ClientAgreedServicesExportInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The date to end calculating the total price of agreed services. */
  endDate?: InputMaybe<Scalars['Date']['input']>;
  /** Only agreed services with expiration on or after this date will be included. */
  expiresOnOrAfter?: InputMaybe<Scalars['Date']['input']>;
  /** The ID of the practice. */
  practiceId: Scalars['ID']['input'];
  /** The date to start calculating the total price of agreed services. */
  startDate?: InputMaybe<Scalars['Date']['input']>;
  /** The id of the logged in user. */
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientAgreedServicesExport. */
export type ClientAgreedServicesExportPayload = {
  __typename: 'ClientAgreedServicesExportPayload';
  backgroundJob: BackgroundJob;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

export type ClientBillingInvoice = {
  __typename: 'ClientBillingInvoice';
  activities?: Maybe<ActivityLogConnection>;
  amount: Money;
  clawbackable: Scalars['Boolean']['output'];
  client: Client;
  date: Scalars['Date']['output'];
  deployments?: Maybe<InvoiceDeploymentConnection>;
  dueDate: Scalars['Date']['output'];
  id: Scalars['ID']['output'];
  items: ClientBillingInvoiceItemConnection;
  latestDeployment?: Maybe<InvoiceDeployment>;
  memo?: Maybe<Scalars['String']['output']>;
  payment?: Maybe<PaymentsPayment>;
  reference: Scalars['String']['output'];
  refundable: Scalars['Boolean']['output'];
  remoteInvoice?: Maybe<Scalars['String']['output']>;
  remoteInvoiceHistory?: Maybe<Scalars['String']['output']>;
  state: ClientBillingInvoiceState;
};

export type ClientBillingInvoiceActivitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ClientBillingInvoiceDeploymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ClientBillingInvoiceItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for ClientBillingInvoice. */
export type ClientBillingInvoiceConnection = {
  __typename: 'ClientBillingInvoiceConnection';
  /** A list of edges. */
  edges: Array<ClientBillingInvoiceEdge>;
  /** A list of nodes. */
  nodes: Array<ClientBillingInvoice>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ClientBillingInvoiceEdge = {
  __typename: 'ClientBillingInvoiceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: ClientBillingInvoice;
};

export type ClientBillingInvoiceFilter = {
  idCont?: InputMaybe<Scalars['String']['input']>;
};

export type ClientBillingInvoiceItem = {
  __typename: 'ClientBillingInvoiceItem';
  amount: Money;
  description?: Maybe<Scalars['String']['output']>;
  discount?: Maybe<Money>;
  name: Scalars['String']['output'];
  notes?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity: Scalars['Decimal']['output'];
  unitPrice: Money;
};

/** The connection type for ClientBillingInvoiceItem. */
export type ClientBillingInvoiceItemConnection = {
  __typename: 'ClientBillingInvoiceItemConnection';
  /** A list of edges. */
  edges: Array<ClientBillingInvoiceItemEdge>;
  /** A list of nodes. */
  nodes: Array<ClientBillingInvoiceItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ClientBillingInvoiceItemEdge = {
  __typename: 'ClientBillingInvoiceItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: ClientBillingInvoiceItem;
};

export enum ClientBillingInvoiceState {
  DELETED = 'DELETED',
  ISSUED = 'ISSUED',
}

/** Autogenerated input type of ClientBulkArchive */
export type ClientBulkArchiveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Maximum number of clients to be archived */
  maxSize?: InputMaybe<Scalars['Int']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  /** Client tag */
  tag: Scalars['String']['input'];
};

/** Autogenerated return type of ClientBulkArchive. */
export type ClientBulkArchivePayload = {
  __typename: 'ClientBulkArchivePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

/** The connection type for Client. */
export type ClientConnection = {
  __typename: 'ClientConnection';
  /** A list of edges. */
  edges: Array<ClientEdge>;
  /** A list of nodes. */
  nodes: Array<Client>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ClientEdge = {
  __typename: 'ClientEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Client;
};

export type ClientFilter = {
  /** Filters clients by name only. */
  nameCont?: InputMaybe<Scalars['String']['input']>;
  /** Filters clients by name or associated contact email */
  nameOrContactsEmailCont?: InputMaybe<Scalars['String']['input']>;
  proposalFilter?: InputMaybe<ProposalFilter>;
  stateNotIn?: InputMaybe<Array<ClientState>>;
};

/** Autogenerated input type of ClientGenerateProposalTemplatePreviews */
export type ClientGenerateProposalTemplatePreviewsInput = {
  /** The ID of the client */
  clientId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientGenerateProposalTemplatePreviews. */
export type ClientGenerateProposalTemplatePreviewsPayload = {
  __typename: 'ClientGenerateProposalTemplatePreviewsPayload';
  client?: Maybe<Client>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

/** Autogenerated input type of ClientMerge */
export type ClientMergeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the target client */
  destinationClientId: Scalars['ID']['input'];
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  /** The ID of the source client */
  sourceClientId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientMerge. */
export type ClientMergePayload = {
  __typename: 'ClientMergePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  destination?: Maybe<Client>;
  source?: Maybe<Client>;
  userErrors?: Maybe<Array<UserError>>;
};

/** Autogenerated input type of ClientSetExcludeFromReports */
export type ClientSetExcludeFromReportsInput = {
  /** The ID of the client */
  clientId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  excludeFromReports: Scalars['Boolean']['input'];
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ClientSetExcludeFromReports. */
export type ClientSetExcludeFromReportsPayload = {
  __typename: 'ClientSetExcludeFromReportsPayload';
  client?: Maybe<Client>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

export enum ClientState {
  ACTIVE = 'ACTIVE',
  ARCHIVED = 'ARCHIVED',
  DELETED = 'DELETED',
  INACTIVE = 'INACTIVE',
  LEAD = 'LEAD',
  LOST = 'LOST',
}

export enum ClientType {
  /** Client used to demonstrate features without influencing real client data. */
  DEMO = 'DEMO',
  /** Normal clients created by practices */
  STANDARD = 'STANDARD',
}

export enum ClientsCount {
  /** 501-1000 clients */
  FIVE_HUNDRED_AND_ONE_TO_ONE_THOUSAND = 'FIVE_HUNDRED_AND_ONE_TO_ONE_THOUSAND',
  /** 101-250 clients */
  ONE_HUNDRED_AND_ONE_TO_TWO_HUNDRED_FIFTY = 'ONE_HUNDRED_AND_ONE_TO_TWO_HUNDRED_FIFTY',
  /** 1001-2000 clients */
  ONE_THOUSAND_AND_ONE_TO_TWO_THOUSAND = 'ONE_THOUSAND_AND_ONE_TO_TWO_THOUSAND',
  /**
   * 1-30 clients
   * @deprecated split into ZERO_TO_NINE and TEN_TO_THIRTY instead
   */
  ONE_TO_THIRTY = 'ONE_TO_THIRTY',
  /** 61-100 clients */
  SIXTY_ONE_TO_ONE_HUNDRED = 'SIXTY_ONE_TO_ONE_HUNDRED',
  /** 10-30 clients */
  TEN_TO_THIRTY = 'TEN_TO_THIRTY',
  /** 31-60 clients */
  THIRTY_ONE_TO_SIXTY = 'THIRTY_ONE_TO_SIXTY',
  /** 251-500 clients */
  TWO_HUNDRED_FIFTY_ONE_TO_FIVE_HUNDRED = 'TWO_HUNDRED_FIFTY_ONE_TO_FIVE_HUNDRED',
  /** 2000+ clients */
  TWO_THOUSAND_PLUS = 'TWO_THOUSAND_PLUS',
  /** 0-9 clients */
  ZERO_TO_NINE = 'ZERO_TO_NINE',
}

export type Contact = {
  __typename: 'Contact';
  emailAddress?: Maybe<Scalars['EmailAddress']['output']>;
  id: Scalars['ID']['output'];
  isDefault: Scalars['Boolean']['output'];
  mobileNumber?: Maybe<Scalars['PhoneNumber']['output']>;
  name: Scalars['String']['output'];
  phoneNumber?: Maybe<Scalars['PhoneNumber']['output']>;
  position?: Maybe<Scalars['String']['output']>;
};

/** The connection type for Contact. */
export type ContactConnection = {
  __typename: 'ContactConnection';
  /** A list of edges. */
  edges: Array<ContactEdge>;
  /** A list of nodes. */
  nodes: Array<Contact>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ContactEdge = {
  __typename: 'ContactEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Contact;
};

export type Currency = {
  __typename: 'Currency';
  /** character between the whole and fraction amounts */
  decimalMark: Scalars['String']['output'];
  /** the international 3-letter code as defined by the ISO 4217 standard */
  isoCode: Scalars['String']['output'];
  /** the international 3-digit code as defined by the ISO 4217 standard */
  isoNumeric: Scalars['String']['output'];
  /** the currency name */
  name: Scalars['String']['output'];
  /** a numerical value you can use to sort/group the currency list */
  priority: Scalars['Int']['output'];
  /** the name of the fractional monetary unit */
  subunit: Scalars['String']['output'];
  /** the proportion between the unit and the subunit */
  subunitToUnit: Scalars['Int']['output'];
  /** the currency symbol (UTF-8 encoded) */
  symbol: Scalars['String']['output'];
  /** character between each thousands place */
  thousandsSeparator: Scalars['String']['output'];
};

/** The connection type for ProposalEditorCustomTemplate. */
export type CustomTemplateConnection = {
  __typename: 'CustomTemplateConnection';
  /** A list of edges. */
  edges: Array<CustomTemplateEdge>;
  /** A list of nodes. */
  nodes: Array<ProposalEditorCustomTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  templatesYaml: Scalars['String']['output'];
};

/** Autogenerated input type of CustomTemplateCreateFromTemplateData */
export type CustomTemplateCreateFromTemplateDataInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The template description */
  description: Scalars['String']['input'];
  /** The template name */
  name: Scalars['String']['input'];
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  /** The template_data in JSON format */
  templateData: Scalars['String']['input'];
};

/** Autogenerated return type of CustomTemplateCreateFromTemplateData. */
export type CustomTemplateCreateFromTemplateDataPayload = {
  __typename: 'CustomTemplateCreateFromTemplateDataPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  customTemplate?: Maybe<ProposalEditorCustomTemplate>;
};

/** Autogenerated input type of CustomTemplateDelete */
export type CustomTemplateDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the custom template */
  customTemplateId: Scalars['ID']['input'];
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of CustomTemplateDelete. */
export type CustomTemplateDeletePayload = {
  __typename: 'CustomTemplateDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  customTemplate?: Maybe<ProposalEditorCustomTemplate>;
};

/** An edge in a connection. */
export type CustomTemplateEdge = {
  __typename: 'CustomTemplateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: ProposalEditorCustomTemplate;
};

export type CustomTemplateFilter = {
  /** Name of the template */
  nameCont?: InputMaybe<Scalars['String']['input']>;
};

export type CustomTemplatePublishSettingsInputType = {
  /** The name of the app. Required if source_type == APP */
  appName?: InputMaybe<Scalars['String']['input']>;
  /** The organization or group the author belongs to */
  authorEntity?: InputMaybe<Scalars['String']['input']>;
  /** The logo of the author entity */
  authorLogoUrl?: InputMaybe<Scalars['String']['input']>;
  /** The name of author of the template */
  authorName?: InputMaybe<Scalars['String']['input']>;
  /** Override the original description of the template */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the optional logo (if different from default) */
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  /** Description of provided templates with formatting */
  longDescription?: InputMaybe<Scalars['String']['input']>;
  /** Override the original name of the template */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Comment made by publisher when approving template */
  publishComment?: InputMaybe<Scalars['String']['input']>;
  /** The name of the source (used for tracking) */
  sourceName?: InputMaybe<Scalars['String']['input']>;
  /** The source_type: IGNITION|APP */
  sourceType?: InputMaybe<CustomTemplateSourceType>;
  /** The type of visibility: PRIVATE|PUBLIC|DEMO */
  visibility?: InputMaybe<CustomTemplateVisibilityState>;
};

export enum CustomTemplateSourceType {
  APP = 'APP',
  IGNITION = 'IGNITION',
}

/** Autogenerated input type of CustomTemplateUpdateFromProposal */
export type CustomTemplateUpdateFromProposalInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the custom template */
  customTemplateId: Scalars['ID']['input'];
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  /** The ID of the proposal */
  proposalId: Scalars['ID']['input'];
  /** The ID of the proposal's practice */
  proposalPracticeId: Scalars['ID']['input'];
  /** Comment made by publisher when approving template */
  publishComment?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CustomTemplateUpdateFromProposal. */
export type CustomTemplateUpdateFromProposalPayload = {
  __typename: 'CustomTemplateUpdateFromProposalPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  customTemplate?: Maybe<ProposalEditorCustomTemplate>;
};

/** Autogenerated input type of CustomTemplateUpdatePublishSettings */
export type CustomTemplateUpdatePublishSettingsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the custom template */
  customTemplateId: Scalars['ID']['input'];
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  /** The publish settings of a custom template */
  publishSettingsInput: CustomTemplatePublishSettingsInputType;
};

/** Autogenerated return type of CustomTemplateUpdatePublishSettings. */
export type CustomTemplateUpdatePublishSettingsPayload = {
  __typename: 'CustomTemplateUpdatePublishSettingsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  customTemplate?: Maybe<ProposalEditorCustomTemplate>;
};

/** Autogenerated input type of CustomTemplateUpdateTemplateData */
export type CustomTemplateUpdateTemplateDataInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the custom template */
  customTemplateId: Scalars['ID']['input'];
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  /** Comment made by publisher when approving template */
  publishComment?: InputMaybe<Scalars['String']['input']>;
  /** The template_data in JSON format */
  templateData: Scalars['String']['input'];
};

/** Autogenerated return type of CustomTemplateUpdateTemplateData. */
export type CustomTemplateUpdateTemplateDataPayload = {
  __typename: 'CustomTemplateUpdateTemplateDataPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  customTemplate?: Maybe<ProposalEditorCustomTemplate>;
};

export enum CustomTemplateVisibilityState {
  DEMO = 'DEMO',
  PRIVATE = 'PRIVATE',
  PUBLIC = 'PUBLIC',
}

export type CustomerSuccessEngagementLetter = {
  __typename: 'CustomerSuccessEngagementLetter';
  createdAt: Scalars['DateTime']['output'];
  creator: User;
  file: Filestack;
  id: Scalars['ID']['output'];
  state: EngagementLetterState;
};

/** The connection type for CustomerSuccessEngagementLetter. */
export type CustomerSuccessEngagementLetterConnection = {
  __typename: 'CustomerSuccessEngagementLetterConnection';
  /** A list of edges. */
  edges: Array<CustomerSuccessEngagementLetterEdge>;
  /** A list of nodes. */
  nodes: Array<CustomerSuccessEngagementLetter>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CustomerSuccessEngagementLetterEdge = {
  __typename: 'CustomerSuccessEngagementLetterEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: CustomerSuccessEngagementLetter;
};

export type CustomerSuccessMaturityIndex = {
  __typename: 'CustomerSuccessMaturityIndex';
  author?: Maybe<Author>;
  clientsCount: ClientsCount;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  industry: Industry;
  ledger: Ledger;
  projectedPercentGrowthForThisYear?: Maybe<Percentage>;
  /** The label of the revenue bracket selected by the user in the CMI form */
  revenueBracketLabel?: Maybe<Scalars['String']['output']>;
  /** Revenue collected from the ledger if one is connected */
  revenueFromLedger?: Maybe<Money>;
  /** Revenue last year collected from dashboard */
  revenueLastYear?: Maybe<Money>;
  score: Scalars['Decimal']['output'];
  /** The calculation version used to generate the CMI index score */
  version: Scalars['Int']['output'];
};

/** Autogenerated input type of CustomerSuccessMaturityIndexCalculate */
export type CustomerSuccessMaturityIndexCalculateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  customerSuccessMaturityIndex: MaturityIndexInput;
};

/** Autogenerated return type of CustomerSuccessMaturityIndexCalculate. */
export type CustomerSuccessMaturityIndexCalculatePayload = {
  __typename: 'CustomerSuccessMaturityIndexCalculatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  customerSuccessMaturityIndex?: Maybe<CustomerSuccessMaturityIndexUnion>;
};

/** Possible maturity index types based on version */
export type CustomerSuccessMaturityIndexUnion =
  | CustomerSuccessMaturityIndex
  | CustomerSuccessVersion1MaturityIndex;

/** The connection type for CustomerSuccessMaturityIndexUnion. */
export type CustomerSuccessMaturityIndexUnionConnection = {
  __typename: 'CustomerSuccessMaturityIndexUnionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomerSuccessMaturityIndexUnionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CustomerSuccessMaturityIndexUnion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CustomerSuccessMaturityIndexUnionEdge = {
  __typename: 'CustomerSuccessMaturityIndexUnionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CustomerSuccessMaturityIndexUnion>;
};

export type CustomerSuccessReferralCopy = {
  __typename: 'CustomerSuccessReferralCopy';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  publisher?: Maybe<AdminUser>;
  title?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type CustomerSuccessVersion1MaturityIndex = {
  __typename: 'CustomerSuccessVersion1MaturityIndex';
  author?: Maybe<Author>;
  clientsCount: ClientsCount;
  createdAt: Scalars['DateTime']['output'];
  feeStructure?: Maybe<FeeStructure>;
  id: Scalars['ID']['output'];
  industry: Industry;
  ledger: Ledger;
  paymentCollectionTool?: Maybe<MaturityIndexPaymentCollectionToolEnum>;
  paymentCollectionToolOther?: Maybe<Scalars['String']['output']>;
  projectedPercentGrowthForThisYear?: Maybe<Percentage>;
  /** The projected percent growth bracket in the version 1 configuration file */
  projectedPercentGrowthForThisYearBracket?: Maybe<MaturityIndexGrowthPercentageBracketEnum>;
  /** Revenue last year collected from dashboard */
  revenueLastYear?: Maybe<Money>;
  /** The bracket that the practice's revenue is mapped in the version 1 configuration file */
  revenueLastYearBracket?: Maybe<MaturityIndexRevenueBracketEnum>;
  score: Scalars['Decimal']['output'];
  staffCount?: Maybe<StaffCount>;
  /** The calculation version used to generate the CMI index score */
  version: Scalars['Int']['output'];
  workflowTool?: Maybe<MaturityIndexWorkflowToolEnum>;
  workflowToolOther?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DisbursalsDisable */
export type DisbursalsDisableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice to disable disbursals for */
  practiceId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of DisbursalsDisable. */
export type DisbursalsDisablePayload = {
  __typename: 'DisbursalsDisablePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

export enum DisbursalsDisablementType {
  DISBURSAL_ACCOUNT_CHANGED = 'DISBURSAL_ACCOUNT_CHANGED',
  FRAUD_DETECTION = 'FRAUD_DETECTION',
  KYC_REQUIRED = 'KYC_REQUIRED',
  REJECTED_BY_STAFF = 'REJECTED_BY_STAFF',
  STRIPE_PAYOUTS_DISABLED = 'STRIPE_PAYOUTS_DISABLED',
  SUBSCRIPTION_EXPIRED = 'SUBSCRIPTION_EXPIRED',
}

/** Autogenerated input type of DisbursalsEnable */
export type DisbursalsEnableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  practiceId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of DisbursalsEnable. */
export type DisbursalsEnablePayload = {
  __typename: 'DisbursalsEnablePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

export type Engagement = {
  __typename: 'Engagement';
  acceptLink: Scalars['URL']['output'];
  audits?: Maybe<AuditConnection>;
  child?: Maybe<Engagement>;
  client?: Maybe<Client>;
  events?: Maybe<EventsEventConnection>;
  /** Engagement's UUID */
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  parent?: Maybe<Engagement>;
  pdfUrl: Scalars['URL']['output'];
  practice: Practice;
  referenceNumber: Scalars['ID']['output'];
  state: EngagementState;
  totalValue: Money;
};

export type EngagementAuditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type EngagementEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of EngagementClientChange */
export type EngagementClientChangeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  practiceId: Scalars['ID']['input'];
  sourceClientId: Scalars['ID']['input'];
  targetClientId: Scalars['ID']['input'];
};

/** Autogenerated return type of EngagementClientChange. */
export type EngagementClientChangePayload = {
  __typename: 'EngagementClientChangePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  source?: Maybe<Client>;
  target?: Maybe<Client>;
  userErrors?: Maybe<Array<UserError>>;
};

/** The connection type for Engagement. */
export type EngagementConnection = {
  __typename: 'EngagementConnection';
  /** A list of edges. */
  edges: Array<EngagementEdge>;
  /** A list of nodes. */
  nodes: Array<Engagement>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EngagementEdge = {
  __typename: 'EngagementEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Engagement;
};

export type EngagementFilter = {
  nameCont?: InputMaybe<Scalars['String']['input']>;
  stateEq?: InputMaybe<EngagementState>;
};

/** Autogenerated input type of EngagementLetterDelete */
export type EngagementLetterDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The UUID of the Engagement */
  engagementLetterId: Scalars['ID']['input'];
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of EngagementLetterDelete. */
export type EngagementLetterDeletePayload = {
  __typename: 'EngagementLetterDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagementLetter: CustomerSuccessEngagementLetter;
};

/** Autogenerated input type of EngagementLetterIntegrate */
export type EngagementLetterIntegrateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The UUID of the Engagement */
  engagementLetterId: Scalars['ID']['input'];
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of EngagementLetterIntegrate. */
export type EngagementLetterIntegratePayload = {
  __typename: 'EngagementLetterIntegratePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  engagementLetter: CustomerSuccessEngagementLetter;
};

export enum EngagementLetterState {
  DELETED = 'DELETED',
  INTEGRATED = 'INTEGRATED',
  PENDING = 'PENDING',
}

export enum EngagementState {
  ACTIVE = 'ACTIVE',
  COMPLETED = 'COMPLETED',
  DELETED = 'DELETED',
  DRAFT = 'DRAFT',
  LOST = 'LOST',
  QUEUED = 'QUEUED',
  SENT = 'SENT',
}

export type EventsEvent = {
  __typename: 'EventsEvent';
  body: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  /** @deprecated Use createdAt */
  creationTime: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  subdomain: Scalars['String']['output'];
};

/** The connection type for EventsEvent. */
export type EventsEventConnection = {
  __typename: 'EventsEventConnection';
  /** A list of edges. */
  edges: Array<EventsEventEdge>;
  /** A list of nodes. */
  nodes: Array<EventsEvent>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EventsEventEdge = {
  __typename: 'EventsEventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: EventsEvent;
};

export type Export = {
  __typename: 'Export';
  id: Scalars['ID']['output'];
  search?: Maybe<Scalars['String']['output']>;
  user: User;
};

export type Feature = {
  __typename: 'Feature';
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  isAvailable: Scalars['Boolean']['output'];
  isEnabled: Scalars['Boolean']['output'];
  isOverridden: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
};

export type FeatureFlag = {
  __typename: 'FeatureFlag';
  id: Scalars['String']['output'];
  isEnabled: Scalars['Boolean']['output'];
};

/** Autogenerated input type of FeatureOverride */
export type FeatureOverrideInput = {
  available: Scalars['Boolean']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the feature to override */
  id: Scalars['ID']['input'];
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of FeatureOverride. */
export type FeatureOverridePayload = {
  __typename: 'FeatureOverridePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  feature: Feature;
};

/** Autogenerated input type of FeatureRemoveOverride */
export type FeatureRemoveOverrideInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The id of the feature to override */
  id: Scalars['ID']['input'];
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of FeatureRemoveOverride. */
export type FeatureRemoveOverridePayload = {
  __typename: 'FeatureRemoveOverridePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  feature: Feature;
};

export enum FeeStructure {
  /** as fixed fee project work */
  FIXED_FEE_PROJECT_WORK = 'FIXED_FEE_PROJECT_WORK',
  /** hourly */
  HOURLY = 'HOURLY',
  /** hourly but switching to fixed fees */
  HOURLY_BUT_SWITCHING = 'HOURLY_BUT_SWITCHING',
  /** as recurring fixed fees */
  RECURRING_FIXED_FEES = 'RECURRING_FIXED_FEES',
}

export type Filestack = {
  __typename: 'Filestack';
  /** The name of the file that was uploaded. */
  filename: Scalars['String']['output'];
  /** The Filestack file handle. This is useful because other Filestack methods accept handles as their input. */
  handle: Scalars['ID']['output'];
  /** The mimetype of the file, if available. */
  mimetype?: Maybe<Scalars['String']['output']>;
  /**
   * This field is reported by the picker at the time the file is uploaded. It is
   * the location where the file was selected from. This can be the location in a
   * user's local file system, or the id or path reported by a cloud drive.
   */
  originalPath: Scalars['String']['output'];
  /**
   * The size of the file in bytes, if available. We will attach this directly to
   * the returned metadata when we have it, otherwise you can always get the size
   * by calling client.metadata(handle)
   */
  size: Scalars['Int']['output'];
  /** The source the file was uploaded from. This could be 'local_file_system', 'instagram', 'dropbox' or any other source. */
  source: Scalars['String']['output'];
  /**
   * The status of the upload. This is not returned if the Filestack link is a
   * symbolic link. Possible statuses are: 'Stored', 'InTransit', and 'Failed'.
   * 'InTransit' means the file has not yet been copied to your bucket, but the
   * Filestack link is valid and won't change once the status changes to 'Stored'.
   * If you have configured webhooks, you will receive a webhook when the status
   * changes to 'Stored'.
   */
  status?: Maybe<Scalars['String']['output']>;
  /** This string value is a UUID that can be used to track files in callbacks. */
  uploadId: Scalars['String']['output'];
  /** The Filestack URL that points to the uploaded file. */
  url: Scalars['URL']['output'];
};

export type FilestackInput = {
  filename: Scalars['String']['input'];
  handle: Scalars['ID']['input'];
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalPath: Scalars['String']['input'];
  size: Scalars['Int']['input'];
  source: Scalars['String']['input'];
  status?: InputMaybe<Scalars['String']['input']>;
  uploadId: Scalars['String']['input'];
  url: Scalars['URL']['input'];
};

export enum Industry {
  /** accounting */
  ACCOUNTING = 'ACCOUNTING',
  /** bookkeeping */
  BOOKKEEPING = 'BOOKKEEPING',
  /** coaching */
  COACHING = 'COACHING',
  /** consulting */
  CONSULTING = 'CONSULTING',
  /** digital agency */
  DIGITAL_AGENCY = 'DIGITAL_AGENCY',
  /** financial services */
  FINANCIAL_SERVICES = 'FINANCIAL_SERVICES',
  /** IT solutions */
  IT_SOLUTIONS = 'IT_SOLUTIONS',
  /** law */
  LAW = 'LAW',
  /** other */
  OTHER = 'OTHER',
  /** software */
  SOFTWARE = 'SOFTWARE',
}

export type Integration = {
  __typename: 'Integration';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  state: Scalars['String']['output'];
};

/** The connection type for Integration. */
export type IntegrationConnection = {
  __typename: 'IntegrationConnection';
  /** A list of edges. */
  edges: Array<IntegrationEdge>;
  /** A list of nodes. */
  nodes: Array<Integration>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type IntegrationEdge = {
  __typename: 'IntegrationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Integration;
};

export type IntegrationFilter = {
  nameEq?: InputMaybe<IntegrationType>;
};

export enum IntegrationType {
  QBO = 'QBO',
  WORKFLOWMAX = 'WORKFLOWMAX',
  XERO = 'XERO',
}

export type InterchangeFee = {
  __typename: 'InterchangeFee';
  /** Card categorisation type, based on the % of interchange fees attributed to a payment collection */
  cardType: InterchangeFeeCardType;
  /** Additional fee on top of the % fee, eg. 2.5% + 30c per transaction */
  feeAddition: Money;
  /** Percentage fee of an interchange fee, eg. 2.5% */
  feePercentage: Percentage;
};

export enum InterchangeFeeCardType {
  PREMIUM = 'PREMIUM',
  STANDARD = 'STANDARD',
}

/** The connection type for InterchangeFee. */
export type InterchangeFeeConnection = {
  __typename: 'InterchangeFeeConnection';
  /** A list of edges. */
  edges: Array<InterchangeFeeEdge>;
  /** A list of nodes. */
  nodes: Array<InterchangeFee>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type InterchangeFeeEdge = {
  __typename: 'InterchangeFeeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: InterchangeFee;
};

export type InvoiceDeployment = {
  __typename: 'InvoiceDeployment';
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  externalId?: Maybe<Scalars['String']['output']>;
  externalNumber?: Maybe<Scalars['String']['output']>;
  externalUrl?: Maybe<Scalars['String']['output']>;
  failedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  ledgerName: Scalars['String']['output'];
  message?: Maybe<Scalars['String']['output']>;
  reference: Scalars['ID']['output'];
  startedAt?: Maybe<Scalars['DateTime']['output']>;
  state: InvoiceDeploymentState;
};

/** The connection type for InvoiceDeployment. */
export type InvoiceDeploymentConnection = {
  __typename: 'InvoiceDeploymentConnection';
  /** A list of edges. */
  edges: Array<InvoiceDeploymentEdge>;
  /** A list of nodes. */
  nodes: Array<InvoiceDeployment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type InvoiceDeploymentEdge = {
  __typename: 'InvoiceDeploymentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: InvoiceDeployment;
};

export enum InvoiceDeploymentState {
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  STARTED = 'STARTED',
}

export enum Ledger {
  /** a different cloud ledger */
  CLOUD_LEDGER = 'CLOUD_LEDGER',
  /** a desktop ledger */
  DESKTOP_LEDGER = 'DESKTOP_LEDGER',
  /** QuickBooks Online */
  QUICKBOOKS_ONLINE = 'QUICKBOOKS_ONLINE',
  /** Xero */
  XERO = 'XERO',
}

export enum MaturityIndexGrowthPercentageBracketEnum {
  /** High growth */
  HIGH_GROWTH = 'HIGH_GROWTH',
  /** Low growth */
  LOW_GROWTH = 'LOW_GROWTH',
  /** Medium growth */
  MEDIUM_GROWTH = 'MEDIUM_GROWTH',
}

export type MaturityIndexInput = {
  clientsCount: ClientsCount;
  feeStructure?: InputMaybe<FeeStructure>;
  industry: Industry;
  ledger: Ledger;
  paymentCollectionTool?: InputMaybe<MaturityIndexPaymentCollectionToolEnum>;
  paymentCollectionToolOther?: InputMaybe<Scalars['String']['input']>;
  practiceId: Scalars['ID']['input'];
  projectedPercentGrowthForThisYear?: InputMaybe<Scalars['BigInt']['input']>;
  revenueBracket?: InputMaybe<MaturityIndexRevenueBracketValueEnum>;
  revenueLastYear?: InputMaybe<Scalars['BigInt']['input']>;
  staffCount?: InputMaybe<StaffCount>;
  workflowTool?: InputMaybe<MaturityIndexWorkflowToolEnum>;
  workflowToolOther?: InputMaybe<Scalars['String']['input']>;
};

export enum MaturityIndexPaymentCollectionToolEnum {
  /** authorize.net */
  AUTHORIZE_NET = 'AUTHORIZE_NET',
  /** bill.com (US) */
  BILL_COM_US = 'BILL_COM_US',
  /** Bpay (AU) */
  BPAY_AU = 'BPAY_AU',
  /** Canopy Tax */
  CANOPY_TAX = 'CANOPY_TAX',
  /** Clients pay invoices with bank transfer/direct deposit */
  CLIENTS_PAY_INVOICES_WITH_BANK_TRANSFER_DIRECT_DEPOSIT = 'CLIENTS_PAY_INVOICES_WITH_BANK_TRANSFER_DIRECT_DEPOSIT',
  /** Clients pay invoices with cheque or cash */
  CLIENTS_PAY_INVOICES_WITH_CHEQUE_OR_CASH = 'CLIENTS_PAY_INVOICES_WITH_CHEQUE_OR_CASH',
  /** Client sets up recurring standing order/eft */
  CLIENT_SETS_UP_RECURRING_STANDING_ORDER_EFT = 'CLIENT_SETS_UP_RECURRING_STANDING_ORDER_EFT',
  /** EziDebit/e-way (AU) */
  EZIDEBIT_E_WAY_AU = 'EZIDEBIT_E_WAY_AU',
  /** GoCardless (Direct) */
  GOCARDLESS_DIRECT = 'GOCARDLESS_DIRECT',
  /** Interac eTransfer (CA) */
  INTERAC_ETRANSFER_CA = 'INTERAC_ETRANSFER_CA',
  /** London & Zurich */
  LONDON_ZURICH = 'LONDON_ZURICH',
  /** Merchant account via my bank */
  MERCHANT_ACCOUNT_VIA_MY_BANK = 'MERCHANT_ACCOUNT_VIA_MY_BANK',
  /** Other */
  OTHER = 'OTHER',
  /** Paypal */
  PAYPAL = 'PAYPAL',
  /** Point of Sale/Terminal */
  POINT_OF_SALE_TERMINAL = 'POINT_OF_SALE_TERMINAL',
  /** I use/I intend to use Ignition Payments */
  PRACTICE_IGNITION_PAYMENTS = 'PRACTICE_IGNITION_PAYMENTS',
  /** QuickBooks Payments */
  QUICKBOOKS_PAYMENTS = 'QUICKBOOKS_PAYMENTS',
  /** Rotessa (CA) */
  ROTESSA_CA = 'ROTESSA_CA',
  /** Square Online Payments */
  SQUARE_ONLINE_PAYMENTS = 'SQUARE_ONLINE_PAYMENTS',
  /** Square Terminal */
  SQUARE_TERMINAL = 'SQUARE_TERMINAL',
  /** Stripe (Direct) */
  STRIPE_DIRECT = 'STRIPE_DIRECT',
  /** Xero Online payments w/ Gocardless */
  XERO_ONLINE_PAYMENTS_W_GOCARDLESS = 'XERO_ONLINE_PAYMENTS_W_GOCARDLESS',
  /** Xero Online payments w/ Stripe */
  XERO_ONLINE_PAYMENTS_W_STRIPE = 'XERO_ONLINE_PAYMENTS_W_STRIPE',
}

export enum MaturityIndexRevenueBracketEnum {
  /** High revenue */
  HIGH_REVENUE = 'HIGH_REVENUE',
  /** Low revenue */
  LOW_REVENUE = 'LOW_REVENUE',
  /** Medium revenue */
  MEDIUM_REVENUE = 'MEDIUM_REVENUE',
}

export enum MaturityIndexRevenueBracketValueEnum {
  HIGH = 'HIGH',
  HIGHEST = 'HIGHEST',
  HIGH_MID = 'HIGH_MID',
  LOW = 'LOW',
  LOWEST = 'LOWEST',
  LOW_MID = 'LOW_MID',
}

export enum MaturityIndexWorkflowToolEnum {
  /** AccountancyManager (UK) */
  ACCOUNTANCYMANAGER_UK = 'ACCOUNTANCYMANAGER_UK',
  /** Aero workflow */
  AERO_WORKFLOW = 'AERO_WORKFLOW',
  /** Airtable */
  AIRTABLE = 'AIRTABLE',
  /** APS / Reckon */
  APS_RECKON = 'APS_RECKON',
  /** Asana */
  ASANA = 'ASANA',
  /** Capium */
  CAPIUM = 'CAPIUM',
  /** CCH axcess */
  CCH_AXCESS = 'CCH_AXCESS',
  /** CCH iFirm */
  CCH_IFIRM = 'CCH_IFIRM',
  /** Clickup */
  CLICKUP = 'CLICKUP',
  /** Digita */
  DIGITA = 'DIGITA',
  /** Google sheets */
  GOOGLE_SHEETS = 'GOOGLE_SHEETS',
  /** HubSpot */
  HUBSPOT = 'HUBSPOT',
  /** Intuit Practice Manager */
  INTUIT_PRACTICE_MANAGER = 'INTUIT_PRACTICE_MANAGER',
  /** In-house built solution */
  IN_HOUSE_BUILT_SOLUTION = 'IN_HOUSE_BUILT_SOLUTION',
  /** IRIS */
  IRIS = 'IRIS',
  /** IRIS Practice Engine */
  IRIS_PRACTICE_ENGINE = 'IRIS_PRACTICE_ENGINE',
  /** Jetpack workflow */
  JETPACK_WORKFLOW = 'JETPACK_WORKFLOW',
  /** Karbon */
  KARBON = 'KARBON',
  /** Microsoft Dynamics */
  MICROSOFT_DYNAMICS = 'MICROSOFT_DYNAMICS',
  /** Microsoft Excel */
  MICROSOFT_EXCEL = 'MICROSOFT_EXCEL',
  /** Monday.com */
  MONDAY_COM = 'MONDAY_COM',
  /** Nomisma */
  NOMISMA = 'NOMISMA',
  /** None */
  NONE = 'NONE',
  /** Onvio */
  ONVIO = 'ONVIO',
  /** Other */
  OTHER = 'OTHER',
  /** Pixie */
  PIXIE = 'PIXIE',
  /** QuickBooks Online Accountant */
  QUICKBOOKS_ONLINE_ACCOUNTANT = 'QUICKBOOKS_ONLINE_ACCOUNTANT',
  /** Sage Handisoft */
  SAGE_HANDISOFT = 'SAGE_HANDISOFT',
  /** Senta */
  SENTA = 'SENTA',
  /** TaxCalc */
  TAXCALC = 'TAXCALC',
  /** Thomson Reuters Practice CS */
  THOMSON_REUTERS_PRACTICE_CS = 'THOMSON_REUTERS_PRACTICE_CS',
  /** Trello */
  TRELLO = 'TRELLO',
  /** Workflow Max */
  WORKFLOW_MAX = 'WORKFLOW_MAX',
  /** Xero Practice Manager */
  XERO_PRACTICE_MANAGER = 'XERO_PRACTICE_MANAGER',
  /** Zoho CRM */
  ZOHO_CRM = 'ZOHO_CRM',
}

export type Money = {
  __typename: 'Money';
  cents: Scalars['BigInt']['output'];
  currency: Currency;
  dollars: Scalars['Decimal']['output'];
  format: Scalars['String']['output'];
};

export type MoneyInput = {
  cents: Scalars['BigInt']['input'];
  currency: Scalars['String']['input'];
};

export type Mutation = {
  __typename: 'Mutation';
  /** @deprecated use PracticeOnboardPayments instead, which implicitly sets up the SUN and other things */
  accountBacsDebitSun?: Maybe<AccountBacsDebitSunPayload>;
  appClientsExport?: Maybe<AppClientsExportPayload>;
  /** Archive all the "ready" proposals for the kickoff in case a mistake was made with the BKO */
  bulkKickOffArchiveProposals?: Maybe<BulkKickoffArchiveProposalsPayload>;
  bulkKickOffCreate?: Maybe<BulkKickOffCreatePayload>;
  /** Schedule the send of all the "ready" proposals for the kickoff */
  bulkKickOffSendProposals?: Maybe<BulkKickoffSendProposalsPayload>;
  cancelScheduledDisbursalsDisablement?: Maybe<CancelScheduledDisbursalsDisablementPayload>;
  /** Exports clients' agreed services */
  clientAgreedServicesExport?: Maybe<ClientAgreedServicesExportPayload>;
  clientBulkArchive?: Maybe<ClientBulkArchivePayload>;
  clientGenerateProposalTemplatePreviews?: Maybe<ClientGenerateProposalTemplatePreviewsPayload>;
  clientMerge?: Maybe<ClientMergePayload>;
  clientSetExcludeFromReports?: Maybe<ClientSetExcludeFromReportsPayload>;
  customTemplateCreateFromTemplateData?: Maybe<CustomTemplateCreateFromTemplateDataPayload>;
  customTemplateDelete?: Maybe<CustomTemplateDeletePayload>;
  customTemplateUpdateFromProposal?: Maybe<CustomTemplateUpdateFromProposalPayload>;
  customTemplateUpdatePublishSettings?: Maybe<CustomTemplateUpdatePublishSettingsPayload>;
  customTemplateUpdateTemplateData?: Maybe<CustomTemplateUpdateTemplateDataPayload>;
  customerSuccessMaturityIndexCalculate?: Maybe<CustomerSuccessMaturityIndexCalculatePayload>;
  disbursalsDisable?: Maybe<DisbursalsDisablePayload>;
  disbursalsEnable?: Maybe<DisbursalsEnablePayload>;
  /** @deprecated Use clientMerge instead */
  engagementClientChange?: Maybe<EngagementClientChangePayload>;
  engagementLetterDelete?: Maybe<EngagementLetterDeletePayload>;
  engagementLetterIntegrate?: Maybe<EngagementLetterIntegratePayload>;
  featureOverride?: Maybe<FeatureOverridePayload>;
  featureRemoveOverride?: Maybe<FeatureRemoveOverridePayload>;
  paymentClawback?: Maybe<PaymentClawbackPayload>;
  paymentRefund?: Maybe<PaymentRefundPayload>;
  paymentRefundApprove?: Maybe<PaymentRefundApprovePayload>;
  paymentRefundDecline?: Maybe<PaymentRefundDeclinePayload>;
  paymentReverse?: Maybe<PaymentReversePayload>;
  practiceBillingSetSubscription?: Maybe<PracticeBillingSetSubscriptionPayload>;
  practiceDeleteArchivedClients?: Maybe<PracticDeleteArchivedClientsPayload>;
  practiceDisable?: Maybe<PracticeDisablePayload>;
  practiceEnable?: Maybe<PracticeEnablePayload>;
  practiceFeatureFlagEnable?: Maybe<PracticeFeatureFlagEnablePayload>;
  /** Undoes the application of a template to the payments setup of a customer. Raises an error if a preset is not applied. */
  practiceOffboardPayments?: Maybe<PracticeOffboardPaymentsPayload>;
  /** Apply a template to the payments setup of a customer. May be done multiple times. */
  practiceOnboardPayments?: Maybe<PracticeOnboardPaymentsPayload>;
  practiceSetCustomActiveClientLimit?: Maybe<PracticeSetCustomActiveClientLimitPayload>;
  practiceSetFraudPaymentThreshold?: Maybe<PracticeSetFraudPaymentThresholdPayload>;
  practiceSetPlanOveragesEnabled?: Maybe<PracticeSetPlanOveragesEnabledPayload>;
  practiceSetPreferredProposalEditor?: Maybe<PracticeSetPreferredProposalEditorPayload>;
  practiceSetPrincipal?: Maybe<PracticeSetPrincipalPayload>;
  practiceSetTfaEffectiveFrom?: Maybe<PracticeSetTfaEffectiveFromPayload>;
  /** Update payment surcharge settings on behalf of a practice */
  practiceSurchargeUpdate?: Maybe<PracticeSurchargeUpdatePayload>;
  practiceTrialRenew?: Maybe<PracticeTrialRenewPayload>;
  /**
   * This should only be run by developer. A developer will use it to update
   * payment method of a proposal's billable services and billing items.
   */
  proposalPaymentMethodAttach?: Maybe<ProposalPaymentMethodAttachPayload>;
  proposalRenewalsImportCreate?: Maybe<ProposalRenewalsImportCreatePayload>;
  /** For marketing to set a proposal as publicly previewable so that anonymous users can preview what the proposal contains */
  proposalSetPreviewable?: Maybe<ProposalSetPreviewablePayload>;
  quickbooksIntegrationProposalBulkCreateFromRecurringTransactions?: Maybe<ProposalBulkCreateFromRecurringTransactionsPayload>;
  quickbooksIntegrationProposalCreateFromRecurringTransaction?: Maybe<ProposalCreateFromQuickbooksRecurringTransactionPayload>;
  referralCopyUpdate?: Maybe<ReferralCopyUpdatePayload>;
  textileConvertLegacyTextile?: Maybe<TextileConvertLegacyTextilePayload>;
  userDelete?: Maybe<UserDeletePayload>;
  userResetTfa?: Maybe<UserResetTfaPayload>;
  userTokenGenerate?: Maybe<UserTokenGeneratePayload>;
  userUpdate?: Maybe<UserUpdatePayload>;
  xeroIntegrationProposalBulkCreateFromRepeatingInvoices?: Maybe<ProposalBulkCreateFromRepeatingInvoicesPayload>;
  xeroIntegrationProposalCreateFromRepeatingInvoice?: Maybe<ProposalCreateFromXeroRepeatingInvoicePayload>;
};

export type MutationAccountBacsDebitSunArgs = {
  input: AccountBacsDebitSunInput;
};

export type MutationAppClientsExportArgs = {
  input: AppClientsExportInput;
};

export type MutationBulkKickOffArchiveProposalsArgs = {
  input: BulkKickoffArchiveProposalsInput;
};

export type MutationBulkKickOffCreateArgs = {
  input: BulkKickOffCreateInput;
};

export type MutationBulkKickOffSendProposalsArgs = {
  input: BulkKickoffSendProposalsInput;
};

export type MutationCancelScheduledDisbursalsDisablementArgs = {
  input: CancelScheduledDisbursalsDisablementInput;
};

export type MutationClientAgreedServicesExportArgs = {
  input: ClientAgreedServicesExportInput;
};

export type MutationClientBulkArchiveArgs = {
  input: ClientBulkArchiveInput;
};

export type MutationClientGenerateProposalTemplatePreviewsArgs = {
  input: ClientGenerateProposalTemplatePreviewsInput;
};

export type MutationClientMergeArgs = {
  input: ClientMergeInput;
};

export type MutationClientSetExcludeFromReportsArgs = {
  input: ClientSetExcludeFromReportsInput;
};

export type MutationCustomTemplateCreateFromTemplateDataArgs = {
  input: CustomTemplateCreateFromTemplateDataInput;
};

export type MutationCustomTemplateDeleteArgs = {
  input: CustomTemplateDeleteInput;
};

export type MutationCustomTemplateUpdateFromProposalArgs = {
  input: CustomTemplateUpdateFromProposalInput;
};

export type MutationCustomTemplateUpdatePublishSettingsArgs = {
  input: CustomTemplateUpdatePublishSettingsInput;
};

export type MutationCustomTemplateUpdateTemplateDataArgs = {
  input: CustomTemplateUpdateTemplateDataInput;
};

export type MutationCustomerSuccessMaturityIndexCalculateArgs = {
  input: CustomerSuccessMaturityIndexCalculateInput;
};

export type MutationDisbursalsDisableArgs = {
  input: DisbursalsDisableInput;
};

export type MutationDisbursalsEnableArgs = {
  input: DisbursalsEnableInput;
};

export type MutationEngagementClientChangeArgs = {
  input: EngagementClientChangeInput;
};

export type MutationEngagementLetterDeleteArgs = {
  input: EngagementLetterDeleteInput;
};

export type MutationEngagementLetterIntegrateArgs = {
  input: EngagementLetterIntegrateInput;
};

export type MutationFeatureOverrideArgs = {
  input: FeatureOverrideInput;
};

export type MutationFeatureRemoveOverrideArgs = {
  input: FeatureRemoveOverrideInput;
};

export type MutationPaymentClawbackArgs = {
  input: PaymentClawbackInput;
};

export type MutationPaymentRefundArgs = {
  input: PaymentRefundInput;
};

export type MutationPaymentRefundApproveArgs = {
  input: PaymentRefundApproveInput;
};

export type MutationPaymentRefundDeclineArgs = {
  input: PaymentRefundDeclineInput;
};

export type MutationPaymentReverseArgs = {
  input: PaymentReverseInput;
};

export type MutationPracticeBillingSetSubscriptionArgs = {
  input: PracticeBillingSetSubscriptionInput;
};

export type MutationPracticeDeleteArchivedClientsArgs = {
  input: PracticDeleteArchivedClientsInput;
};

export type MutationPracticeDisableArgs = {
  input: PracticeDisableInput;
};

export type MutationPracticeEnableArgs = {
  input: PracticeEnableInput;
};

export type MutationPracticeFeatureFlagEnableArgs = {
  input: PracticeFeatureFlagEnableInput;
};

export type MutationPracticeOffboardPaymentsArgs = {
  input: PracticeOffboardPaymentsInput;
};

export type MutationPracticeOnboardPaymentsArgs = {
  input: PracticeOnboardPaymentsInput;
};

export type MutationPracticeSetCustomActiveClientLimitArgs = {
  input: PracticeSetCustomActiveClientLimitInput;
};

export type MutationPracticeSetFraudPaymentThresholdArgs = {
  input: PracticeSetFraudPaymentThresholdInput;
};

export type MutationPracticeSetPlanOveragesEnabledArgs = {
  input: PracticeSetPlanOveragesEnabledInput;
};

export type MutationPracticeSetPreferredProposalEditorArgs = {
  input: PracticeSetPreferredProposalEditorInput;
};

export type MutationPracticeSetPrincipalArgs = {
  input: PracticeSetPrincipalInput;
};

export type MutationPracticeSetTfaEffectiveFromArgs = {
  input: PracticeSetTfaEffectiveFromInput;
};

export type MutationPracticeSurchargeUpdateArgs = {
  input: PracticeSurchargeUpdateInput;
};

export type MutationPracticeTrialRenewArgs = {
  input: PracticeTrialRenewInput;
};

export type MutationProposalPaymentMethodAttachArgs = {
  input: ProposalPaymentMethodAttachInput;
};

export type MutationProposalRenewalsImportCreateArgs = {
  input: ProposalRenewalsImportCreateInput;
};

export type MutationProposalSetPreviewableArgs = {
  input: ProposalSetPreviewableInput;
};

export type MutationQuickbooksIntegrationProposalBulkCreateFromRecurringTransactionsArgs =
  {
    input: ProposalBulkCreateFromRecurringTransactionsInput;
  };

export type MutationQuickbooksIntegrationProposalCreateFromRecurringTransactionArgs =
  {
    input: ProposalCreateFromQuickbooksRecurringTransactionInput;
  };

export type MutationReferralCopyUpdateArgs = {
  input: ReferralCopyUpdateInput;
};

export type MutationTextileConvertLegacyTextileArgs = {
  input: TextileConvertLegacyTextileInput;
};

export type MutationUserDeleteArgs = {
  input: UserDeleteInput;
};

export type MutationUserResetTfaArgs = {
  input: UserResetTfaInput;
};

export type MutationUserTokenGenerateArgs = {
  input: UserTokenGenerateInput;
};

export type MutationUserUpdateArgs = {
  input: UserUpdateInput;
};

export type MutationXeroIntegrationProposalBulkCreateFromRepeatingInvoicesArgs =
  {
    input: ProposalBulkCreateFromRepeatingInvoicesInput;
  };

export type MutationXeroIntegrationProposalCreateFromRepeatingInvoiceArgs = {
  input: ProposalCreateFromXeroRepeatingInvoiceInput;
};

export type NotificationsSettings = {
  __typename: 'NotificationsSettings';
  audits?: Maybe<AuditConnection>;
  notificationType: Scalars['String']['output'];
  remindersRecurrenceRule?: Maybe<Scalars['String']['output']>;
  state: Scalars['String']['output'];
};

export type NotificationsSettingsAuditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for NotificationsSettings. */
export type NotificationsSettingsConnection = {
  __typename: 'NotificationsSettingsConnection';
  /** A list of edges. */
  edges: Array<NotificationsSettingsEdge>;
  /** A list of nodes. */
  nodes: Array<NotificationsSettings>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type NotificationsSettingsEdge = {
  __typename: 'NotificationsSettingsEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: NotificationsSettings;
};

export type NotificationsSettingsFilter = {
  notificationType?: InputMaybe<Scalars['String']['input']>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of PaymentClawback */
export type PaymentClawbackInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Payment */
  paymentId: Scalars['ID']['input'];
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of PaymentClawback. */
export type PaymentClawbackPayload = {
  __typename: 'PaymentClawbackPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  invoice?: Maybe<ClientBillingInvoice>;
  payment?: Maybe<PaymentsPayment>;
};

export type PaymentMethod = {
  __typename: 'PaymentMethod';
  createdAt: Scalars['DateTime']['output'];
  currency: Currency;
  expiryDate?: Maybe<Scalars['Date']['output']>;
  gatewayId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  isVerified: Scalars['Boolean']['output'];
  name?: Maybe<Scalars['String']['output']>;
  numberSuffix?: Maybe<Scalars['String']['output']>;
  status: PaymentMethodStatus;
  type?: Maybe<PaymentMethodType>;
  updatedAt: Scalars['DateTime']['output'];
};

export type PaymentMethodFee = {
  __typename: 'PaymentMethodFee';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  creditCardBrand?: Maybe<Scalars['String']['output']>;
  creditCardType?: Maybe<Scalars['String']['output']>;
  expiresAt?: Maybe<Scalars['DateTime']['output']>;
  feeAddition: Money;
  feeAmount?: Maybe<Money>;
  feeMaximum?: Maybe<Money>;
  feeMinimum?: Maybe<Money>;
  feePercentage?: Maybe<Percentage>;
  feeType: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  paymentMethodCurrency: Scalars['String']['output'];
  paymentMethodType: Scalars['String']['output'];
  planTier?: Maybe<Scalars['String']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
  tenantId?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** The connection type for PaymentMethodFee. */
export type PaymentMethodFeeConnection = {
  __typename: 'PaymentMethodFeeConnection';
  /** A list of edges. */
  edges: Array<PaymentMethodFeeEdge>;
  /** A list of nodes. */
  nodes: Array<PaymentMethodFee>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PaymentMethodFeeEdge = {
  __typename: 'PaymentMethodFeeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: PaymentMethodFee;
};

export enum PaymentMethodStatus {
  ACTIVE = 'ACTIVE',
  DELETED = 'DELETED',
}

export enum PaymentMethodType {
  BANK_ACCOUNT = 'BANK_ACCOUNT',
  CREDIT_CARD = 'CREDIT_CARD',
}

/** Autogenerated input type of PaymentRefundApprove */
export type PaymentRefundApproveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Refund we are approving */
  id: Scalars['ID']['input'];
  /** The ID of the Practice we are approving the refund for */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of PaymentRefundApprove. */
export type PaymentRefundApprovePayload = {
  __typename: 'PaymentRefundApprovePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  refund: PaymentsRefund;
};

/** Autogenerated input type of PaymentRefundDecline */
export type PaymentRefundDeclineInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Refund we are declining */
  id: Scalars['ID']['input'];
  /** The ID of the Practice we are declining the refund for */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of PaymentRefundDecline. */
export type PaymentRefundDeclinePayload = {
  __typename: 'PaymentRefundDeclinePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  refund: PaymentsRefund;
};

/** Autogenerated input type of PaymentRefund */
export type PaymentRefundInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Payment */
  paymentId: Scalars['ID']['input'];
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of PaymentRefund. */
export type PaymentRefundPayload = {
  __typename: 'PaymentRefundPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  invoice?: Maybe<ClientBillingInvoice>;
  payment?: Maybe<PaymentsPayment>;
};

/** Autogenerated input type of PaymentReverse */
export type PaymentReverseInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Payment */
  paymentId: Scalars['ID']['input'];
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of PaymentReverse. */
export type PaymentReversePayload = {
  __typename: 'PaymentReversePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  invoice?: Maybe<ClientBillingInvoice>;
  payment?: Maybe<PaymentsPayment>;
};

export type PaymentsClawback = {
  __typename: 'PaymentsClawback';
  amount: Money;
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  createdAt: Scalars['DateTime']['output'];
  externalId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  message?: Maybe<Scalars['String']['output']>;
  paymentMethod: PaymentMethod;
  startedAt?: Maybe<Scalars['DateTime']['output']>;
  state: PaymentsClawbackState;
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for PaymentsClawback. */
export type PaymentsClawbackConnection = {
  __typename: 'PaymentsClawbackConnection';
  /** A list of edges. */
  edges: Array<PaymentsClawbackEdge>;
  /** A list of nodes. */
  nodes: Array<PaymentsClawback>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PaymentsClawbackEdge = {
  __typename: 'PaymentsClawbackEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: PaymentsClawback;
};

export enum PaymentsClawbackState {
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  STARTED = 'STARTED',
}

export type PaymentsCollection = {
  __typename: 'PaymentsCollection';
  amount: Money;
  /** The client associated to this collection */
  client?: Maybe<Client>;
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  createdAt: Scalars['DateTime']['output'];
  dashboardUri?: Maybe<Scalars['String']['output']>;
  externalId?: Maybe<Scalars['String']['output']>;
  failedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  invoice?: Maybe<ClientBillingInvoice>;
  message?: Maybe<Scalars['String']['output']>;
  paymentMethod: PaymentMethod;
  scheduledTime?: Maybe<Scalars['DateTime']['output']>;
  startedAt?: Maybe<Scalars['DateTime']['output']>;
  state: PaymentsCollectionState;
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for PaymentsCollection. */
export type PaymentsCollectionConnection = {
  __typename: 'PaymentsCollectionConnection';
  /** A list of edges. */
  edges: Array<PaymentsCollectionEdge>;
  /** A list of nodes. */
  nodes: Array<PaymentsCollection>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PaymentsCollectionEdge = {
  __typename: 'PaymentsCollectionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: PaymentsCollection;
};

export enum PaymentsCollectionState {
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  STARTED = 'STARTED',
}

export type PaymentsDisbursal = {
  __typename: 'PaymentsDisbursal';
  amount: Money;
  availableOn: Scalars['Date']['output'];
  externalId: Scalars['String']['output'];
  feeAmount: Money;
  feeDescription: Scalars['String']['output'];
  /** Disbursal slug */
  id: Scalars['ID']['output'];
  payments?: Maybe<PaymentsPaymentConnection>;
  payout?: Maybe<StripePayout>;
  startedAt: Scalars['DateTime']['output'];
  state: PaymentsDisbursalStateEnum;
};

export type PaymentsDisbursalPaymentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for PaymentsDisbursal. */
export type PaymentsDisbursalConnection = {
  __typename: 'PaymentsDisbursalConnection';
  /** A list of edges. */
  edges: Array<PaymentsDisbursalEdge>;
  /** A list of nodes. */
  nodes: Array<PaymentsDisbursal>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PaymentsDisbursalEdge = {
  __typename: 'PaymentsDisbursalEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: PaymentsDisbursal;
};

export type PaymentsDisbursalFilter = {
  externalIdCont?: InputMaybe<Scalars['String']['input']>;
  idEq?: InputMaybe<Scalars['ID']['input']>;
};

export enum PaymentsDisbursalStateEnum {
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  STARTED = 'STARTED',
}

/** Additional expenses added to the price of a transaction */
export type PaymentsFee = {
  __typename: 'PaymentsFee';
  /** A amount per charge */
  amount?: Maybe<Money>;
  /** The description of the fee based on */
  description?: Maybe<Scalars['String']['output']>;
};

/** Payments Settings onboarded preset, used to preset configurations such as payment fees and custom BACS */
export enum PaymentsOnboardedPresetType {
  BANK_ACCOUNT_PAYMENT_DISCOUNT = 'BANK_ACCOUNT_PAYMENT_DISCOUNT',
  HIGH_VALUE = 'HIGH_VALUE',
  INTERNAL = 'INTERNAL',
  PARTNERSHIP_CARBON_GROUP = 'PARTNERSHIP_CARBON_GROUP',
  PARTNERSHIP_TAX_ASSIST = 'PARTNERSHIP_TAX_ASSIST',
  PARTNERSHIP_XEINADIN_GROUP = 'PARTNERSHIP_XEINADIN_GROUP',
  SUPER_HIGH_VALUE = 'SUPER_HIGH_VALUE',
  TWENTY_TWENTY_THREE_NO_FEES_THREE_MONTHS = 'TWENTY_TWENTY_THREE_NO_FEES_THREE_MONTHS',
}

export type PaymentsPayment = {
  __typename: 'PaymentsPayment';
  activities?: Maybe<ActivityLogConnection>;
  amount: Money;
  availableOn?: Maybe<Scalars['Date']['output']>;
  canCollect: Scalars['Boolean']['output'];
  clawbacks?: Maybe<PaymentsClawbackConnection>;
  collections?: Maybe<PaymentsCollectionConnection>;
  createdAt: Scalars['DateTime']['output'];
  fee?: Maybe<PaymentsFee>;
  id: Scalars['ID']['output'];
  invoice?: Maybe<ClientBillingInvoice>;
  /** Payment disbursals associated with the payment, not a direct representation of PaymentsDisbursal type */
  paymentDisbursals?: Maybe<PaymentsPaymentDisbursalConnection>;
  paymentMethod: PaymentMethod;
  reference: Scalars['String']['output'];
  refunds?: Maybe<PaymentsRefundConnection>;
  scheduledCollectionTime?: Maybe<Scalars['DateTime']['output']>;
  state: PaymentsPaymentStateEnum;
  updatedAt: Scalars['DateTime']['output'];
};

export type PaymentsPaymentActivitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PaymentsPaymentClawbacksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PaymentsPaymentCollectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PaymentsPaymentPaymentDisbursalsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PaymentsPaymentRefundsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<RefundsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for PaymentsPayment. */
export type PaymentsPaymentConnection = {
  __typename: 'PaymentsPaymentConnection';
  /** A list of edges. */
  edges: Array<PaymentsPaymentEdge>;
  /** A list of nodes. */
  nodes: Array<PaymentsPayment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type PaymentsPaymentDisbursal = {
  __typename: 'PaymentsPaymentDisbursal';
  externalId: Scalars['String']['output'];
  /** Disbursal slug */
  id: Scalars['ID']['output'];
  startedAt: Scalars['DateTime']['output'];
  state: PaymentsDisbursalStateEnum;
};

/** The connection type for PaymentsPaymentDisbursal. */
export type PaymentsPaymentDisbursalConnection = {
  __typename: 'PaymentsPaymentDisbursalConnection';
  /** A list of edges. */
  edges: Array<PaymentsPaymentDisbursalEdge>;
  /** A list of nodes. */
  nodes: Array<PaymentsPaymentDisbursal>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PaymentsPaymentDisbursalEdge = {
  __typename: 'PaymentsPaymentDisbursalEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: PaymentsPaymentDisbursal;
};

/** An edge in a connection. */
export type PaymentsPaymentEdge = {
  __typename: 'PaymentsPaymentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: PaymentsPayment;
};

export enum PaymentsPaymentStateEnum {
  CANCELLED = 'CANCELLED',
  CLAWING_BACK = 'CLAWING_BACK',
  COLLECTED = 'COLLECTED',
  COLLECTING = 'COLLECTING',
  DISBURSED = 'DISBURSED',
  DISBURSING = 'DISBURSING',
  REFUNDED = 'REFUNDED',
  REFUNDING = 'REFUNDING',
  UNCOLLECTED = 'UNCOLLECTED',
}

export type PaymentsRefund = {
  __typename: 'PaymentsRefund';
  amount: Money;
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  createdAt: Scalars['DateTime']['output'];
  externalId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  message?: Maybe<Scalars['String']['output']>;
  payment: PaymentsPayment;
  paymentMethod: PaymentMethod;
  /** Payment refund reason */
  reason?: Maybe<Scalars['String']['output']>;
  startedAt?: Maybe<Scalars['DateTime']['output']>;
  state: PaymentsRefundState;
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for PaymentsRefund. */
export type PaymentsRefundConnection = {
  __typename: 'PaymentsRefundConnection';
  /** A list of edges. */
  edges: Array<PaymentsRefundEdge>;
  /** A list of nodes. */
  nodes: Array<PaymentsRefund>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PaymentsRefundEdge = {
  __typename: 'PaymentsRefundEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: PaymentsRefund;
};

export enum PaymentsRefundState {
  APPROVED = 'APPROVED',
  CANCELED = 'CANCELED',
  COMPLETED = 'COMPLETED',
  DECLINED = 'DECLINED',
  FAILED = 'FAILED',
  PENDING = 'PENDING',
  STARTED = 'STARTED',
}

export type PaymentsSettings = {
  __typename: 'PaymentsSettings';
  audits?: Maybe<AuditConnection>;
  /** Whether this practice is collecting payments via credit card */
  creditCardAccepted: Scalars['Boolean']['output'];
  /** Whether this practice is collecting payments via direct debit */
  directDebitAccepted: Scalars['Boolean']['output'];
  /** Whether direct debit collections can be turned on for this practice */
  directDebitSupported: Scalars['Boolean']['output'];
  /** Scheduled date disbursals will be disabled for this practice. Clears once a practice's disbursals have been disabled */
  disableDisbursalsAt?: Maybe<Scalars['DateTime']['output']>;
  /** Disbursals Disablement Linked Payment Collection */
  disbursalsDisablementLinkedCollection?: Maybe<PaymentsCollection>;
  /** Disbursals Disablement Type */
  disbursalsDisablementType?: Maybe<DisbursalsDisablementType>;
  /** Fraud Payment Threshold */
  fraudPaymentThreshold?: Maybe<Money>;
  hasDisbursalAccount: Scalars['Boolean']['output'];
  /** Are collections enabled? */
  isCollectionsEnabled: Scalars['Boolean']['output'];
  /** Are disbursals enabled? */
  isDisbursalsEnabled: Scalars['Boolean']['output'];
  /** Whether surcharges are restricted to only the 'credit_card' surcharge category */
  isSurchargeCreditCardsOnly: Scalars['Boolean']['output'];
  /** Whether a practice can use surcharges to pass on payment fees to their clients */
  isSurchargeEnabled: Scalars['Boolean']['output'];
  /** Settings configuration applied to practice */
  onboardedPreset?: Maybe<PaymentsOnboardedPresetType>;
  /** Number of days a payment will be collected after an invoice for one-off payment is raised */
  onceOffTerms: Scalars['Int']['output'];
  /** The percentage fee discount applied to any payment fees incurred */
  paymentFeeDiscount?: Maybe<Percentage>;
  /** Whether this practice requires a valid payment method from a client when a proposal is accepted */
  paymentMethodRequired: Scalars['Boolean']['output'];
  /** Number of days a payment will be collected after an invoice for a recurring payment is raised */
  recurringTerms: Scalars['Int']['output'];
  /** Description of the most recent change to surcharge settings */
  surchargeLastUpdateMessage?: Maybe<Scalars['String']['output']>;
  /** Rate at which applicable cards are surcharged */
  surchargeRate: Percentage;
};

export type PaymentsSettingsAuditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type Percentage = {
  __typename: 'Percentage';
  format: Scalars['String']['output'];
  value: Scalars['Decimal']['output'];
};

export type PercentageInput = {
  /** Value as a percentage, e.g. 10% */
  percentage?: InputMaybe<Scalars['Float']['input']>;
  /** Percentage as a value, e.g. 0.1 */
  value?: InputMaybe<Scalars['Float']['input']>;
};

export type Plan = {
  __typename: 'Plan';
  billingPeriod: PlanBillingPeriod;
  code: Scalars['String']['output'];
  /** If set, defines the active client limit for this practice overriding the default provided by their plan. */
  customActiveClientLimit?: Maybe<Scalars['Int']['output']>;
  isEligible: Scalars['Boolean']['output'];
  isLegacy: Scalars['Boolean']['output'];
  maxClients: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  overagesEnabled: Scalars['Boolean']['output'];
  price: Money;
  tier: PlanNameEnum;
};

export enum PlanBillingPeriod {
  /** Billed annually */
  ANNUALLY = 'ANNUALLY',
  /** Billed monthly */
  MONTHLY = 'MONTHLY',
}

export enum PlanNameEnum {
  BOOKKEEPER = 'BOOKKEEPER',
  CORE = 'CORE',
  /** Legacy plan */
  JUPITER = 'JUPITER',
  /** Legacy plan */
  MARS = 'MARS',
  /** Legacy plan */
  NEPTUNE = 'NEPTUNE',
  NONE = 'NONE',
  PRO = 'PRO',
  PROFESSIONAL = 'PROFESSIONAL',
  PROPLUS = 'PROPLUS',
  /** Legacy plan */
  SATURN = 'SATURN',
  SCALE = 'SCALE',
  STARTER = 'STARTER',
  TRIAL = 'TRIAL',
}

/** Autogenerated input type of PracticDeleteArchivedClients */
export type PracticDeleteArchivedClientsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of PracticDeleteArchivedClients. */
export type PracticDeleteArchivedClientsPayload = {
  __typename: 'PracticDeleteArchivedClientsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

export type Practice = {
  __typename: 'Practice';
  audits?: Maybe<AuditConnection>;
  billingCurrency: Currency;
  brandingTheme: BrandingTheme;
  bulkKickOffs?: Maybe<BulkKickOffConnection>;
  client?: Maybe<Client>;
  clients?: Maybe<ClientConnection>;
  /** List of revenue brackets for cmi questions based on the current practice region */
  cmiRevenueBrackets: Array<RevenueBracket>;
  countryCode?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  currencySymbol: Scalars['String']['output'];
  customTemplates?: Maybe<CustomTemplateConnection>;
  customerSuccessMaturityIndex?: Maybe<CustomerSuccessMaturityIndexUnion>;
  customerSuccessMaturityIndices?: Maybe<CustomerSuccessMaturityIndexUnionConnection>;
  /** Default service grouping for new proposals. This will be used unless otherwise changed within the proposal editor. */
  defaultBillingGroupedBy: BillingGroupedByType;
  disabled: Scalars['Boolean']['output'];
  disabledReasonCategory?: Maybe<PracticeDisabledReasonCategory>;
  email?: Maybe<Scalars['EmailAddress']['output']>;
  engagement?: Maybe<Engagement>;
  engagementLetters?: Maybe<CustomerSuccessEngagementLetterConnection>;
  engagements?: Maybe<EngagementConnection>;
  feature?: Maybe<Feature>;
  featureFlag: FeatureFlag;
  features: Array<Feature>;
  id: Scalars['ID']['output'];
  integrations?: Maybe<IntegrationConnection>;
  intent: PracticeIntentEnum;
  interchangeFees: InterchangeFeeConnection;
  internal: Scalars['Boolean']['output'];
  ledgerName?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  notificationsSettings: NotificationsSettingsConnection;
  /** Practice assigned payment gateways */
  paymentGateways?: Maybe<Array<PracticePaymentGateway>>;
  paymentMethodFees?: Maybe<PaymentMethodFeeConnection>;
  paymentSettings: PaymentsSettings;
  paymentsDisbursals?: Maybe<PaymentsDisbursalConnection>;
  phone?: Maybe<Scalars['String']['output']>;
  plan?: Maybe<Plan>;
  preferredProposalEditor?: Maybe<ProposalEditor>;
  principal?: Maybe<User>;
  proposal?: Maybe<Proposal>;
  proposalTemplatePublishRegion?: Maybe<Scalars['String']['output']>;
  /** List of Quickbooks Recurring Transactions */
  quickbooksRecurringTransactions?: Maybe<QuickbooksRecurringTransactionConnection>;
  recurlyAccountUrl?: Maybe<Scalars['URL']['output']>;
  referenceNumber: Scalars['ID']['output'];
  /**
   * The referral copy published for a particular region.
   *                       Only applicable on special practices with 'proposal_template_publish_region' defined.
   */
  referralCopy?: Maybe<CustomerSuccessReferralCopy>;
  region?: Maybe<Scalars['String']['output']>;
  renewalsImports?: Maybe<RenewalsImportConnection>;
  services: ServiceTypeConnection;
  slug: Scalars['String']['output'];
  stripeIntegrationAccount?: Maybe<StripeIntegrationAccount>;
  templates?: Maybe<TemplateConnection>;
  tfaEffectiveFrom?: Maybe<Scalars['Date']['output']>;
  timeZone: TimeZone;
  trialEndDate?: Maybe<Scalars['Date']['output']>;
  twoFactorAuthRequired: Scalars['Boolean']['output'];
  /** Find a User by ID */
  user?: Maybe<User>;
  users?: Maybe<UserConnection>;
  /** List of Xero Repeating Invoices */
  xeroRepeatingInvoices?: Maybe<XeroIntegrationRepeatingInvoiceConnection>;
};

export type PracticeAuditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PracticeBulkKickOffsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<BulkKickOffFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PracticeClientArgs = {
  id: Scalars['ID']['input'];
};

export type PracticeClientsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ClientFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PracticeCustomTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<CustomTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PracticeCustomerSuccessMaturityIndicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PracticeEngagementArgs = {
  id: Scalars['ID']['input'];
};

export type PracticeEngagementLettersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PracticeEngagementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EngagementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PracticeFeatureArgs = {
  id: Scalars['ID']['input'];
};

export type PracticeFeatureFlagArgs = {
  id: Scalars['String']['input'];
};

export type PracticeIntegrationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<IntegrationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PracticeInterchangeFeesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PracticeNotificationsSettingsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<NotificationsSettingsFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PracticePaymentMethodFeesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PracticePaymentsDisbursalsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<PaymentsDisbursalFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PracticeProposalArgs = {
  id: Scalars['ID']['input'];
};

export type PracticeQuickbooksRecurringTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  recurringTransactionType?: InputMaybe<Scalars['String']['input']>;
};

export type PracticeRenewalsImportsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<RenewalsImportFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PracticeServicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ServiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PracticeTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<TemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PracticeUserArgs = {
  id: Scalars['ID']['input'];
};

export type PracticeUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type PracticeXeroRepeatingInvoicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
};

export enum PracticeBillingPlanFrequency {
  ANNUALLY = 'ANNUALLY',
  MONTHLY = 'MONTHLY',
}

/** The connection type for Practice. */
export type PracticeConnection = {
  __typename: 'PracticeConnection';
  /** A list of edges. */
  edges: Array<PracticeEdge>;
  /** A list of nodes. */
  nodes: Array<Practice>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of PracticeDisable */
export type PracticeDisableInput = {
  cancelSubscription?: InputMaybe<Scalars['Boolean']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  reason: Scalars['String']['input'];
  reasonCategory: PracticeDisabledReasonCategory;
};

/** Autogenerated return type of PracticeDisable. */
export type PracticeDisablePayload = {
  __typename: 'PracticeDisablePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
  userErrors?: Maybe<Array<UserError>>;
};

export enum PracticeDisabledReasonCategory {
  ADMIN_ACCIDENTAL_TRIAL_EXTENSION = 'ADMIN_ACCIDENTAL_TRIAL_EXTENSION',
  ADMIN_RESET = 'ADMIN_RESET',
  CUSTOMER_ACCIDENTAL_CREATION = 'CUSTOMER_ACCIDENTAL_CREATION',
  CUSTOMER_REQUEST = 'CUSTOMER_REQUEST',
  OTHER = 'OTHER',
  SUSPECT_FRAUD = 'SUSPECT_FRAUD',
}

/** An edge in a connection. */
export type PracticeEdge = {
  __typename: 'PracticeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Practice;
};

/** Autogenerated input type of PracticeEnable */
export type PracticeEnableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of PracticeEnable. */
export type PracticeEnablePayload = {
  __typename: 'PracticeEnablePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

/** Autogenerated input type of PracticeFeatureFlagEnable */
export type PracticeFeatureFlagEnableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The "id" of the feature */
  id: Scalars['String']['input'];
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of PracticeFeatureFlagEnable. */
export type PracticeFeatureFlagEnablePayload = {
  __typename: 'PracticeFeatureFlagEnablePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  featureFlag: FeatureFlag;
};

export type PracticeFilter = {
  idEq?: InputMaybe<Scalars['String']['input']>;
  nameCont?: InputMaybe<Scalars['String']['input']>;
  subscriptionStatusEq?: InputMaybe<SubscriptionStatus>;
};

export enum PracticeIntentEnum {
  EFFICIENCY = 'EFFICIENCY',
  GROWTH = 'GROWTH',
  PAYMENTS = 'PAYMENTS',
  PROFIT = 'PROFIT',
  UNKNOWN = 'UNKNOWN',
}

/** Autogenerated input type of PracticeOffboardPayments */
export type PracticeOffboardPaymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of PracticeOffboardPayments. */
export type PracticeOffboardPaymentsPayload = {
  __typename: 'PracticeOffboardPaymentsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

/** Autogenerated input type of PracticeOnboardPayments */
export type PracticeOnboardPaymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  /** The template configuration */
  preset: PaymentsOnboardedPresetType;
};

/** Autogenerated return type of PracticeOnboardPayments. */
export type PracticeOnboardPaymentsPayload = {
  __typename: 'PracticeOnboardPaymentsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

export type PracticePaymentGateway = {
  __typename: 'PracticePaymentGateway';
  /** Flag to indicate if gateway is active for a practice */
  active: Scalars['Boolean']['output'];
  gatewayId: Scalars['String']['output'];
  processorId: Scalars['String']['output'];
};

/** Autogenerated input type of PracticeSetCustomActiveClientLimit */
export type PracticeSetCustomActiveClientLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** New active client limit */
  limit?: InputMaybe<Scalars['Int']['input']>;
  /** The ID of the Practice to update */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of PracticeSetCustomActiveClientLimit. */
export type PracticeSetCustomActiveClientLimitPayload = {
  __typename: 'PracticeSetCustomActiveClientLimitPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

/** Autogenerated input type of PracticeSetFraudPaymentThreshold */
export type PracticeSetFraudPaymentThresholdInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Fraud Payment Threshold */
  fraudPaymentThreshold: MoneyInput;
  /** The ID of the Practice to set fraud payment threshold for */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of PracticeSetFraudPaymentThreshold. */
export type PracticeSetFraudPaymentThresholdPayload = {
  __typename: 'PracticeSetFraudPaymentThresholdPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

/** Autogenerated input type of PracticeSetPlanOveragesEnabled */
export type PracticeSetPlanOveragesEnabledInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  id: Scalars['ID']['input'];
  /** Whether or not overages are to be enabled */
  overagesEnabled: Scalars['Boolean']['input'];
};

/** Autogenerated return type of PracticeSetPlanOveragesEnabled. */
export type PracticeSetPlanOveragesEnabledPayload = {
  __typename: 'PracticeSetPlanOveragesEnabledPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

/** Autogenerated input type of PracticeSetPreferredProposalEditor */
export type PracticeSetPreferredProposalEditorInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  /** The preferred proposal editor. Null means no preference. */
  preferredProposalEditor?: InputMaybe<ProposalEditor>;
};

/** Autogenerated return type of PracticeSetPreferredProposalEditor. */
export type PracticeSetPreferredProposalEditorPayload = {
  __typename: 'PracticeSetPreferredProposalEditorPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice: Practice;
};

/** Autogenerated input type of PracticeSetPrincipal */
export type PracticeSetPrincipalInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  /** The ID of the User being set as new Principal */
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of PracticeSetPrincipal. */
export type PracticeSetPrincipalPayload = {
  __typename: 'PracticeSetPrincipalPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
  principal?: Maybe<User>;
};

/** Autogenerated input type of PracticeSetTfaEffectiveFrom */
export type PracticeSetTfaEffectiveFromInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The effective date (ISO Formatted) of requiring two factor auth for all practice users  */
  date: Scalars['Date']['input'];
  /** The ID of the Practice */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of PracticeSetTfaEffectiveFrom. */
export type PracticeSetTfaEffectiveFromPayload = {
  __typename: 'PracticeSetTfaEffectiveFromPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

/** Autogenerated input type of PracticeSurchargeUpdate */
export type PracticeSurchargeUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Whether surcharges are restricted to only the 'credit_card' surcharge category */
  isSurchargeCreditCardsOnly: Scalars['Boolean']['input'];
  /** The slug of the practice to have its surcharge settings updated */
  practiceId: Scalars['ID']['input'];
  /** Rate at which applicable cards are surcharged */
  surchargeRate: PercentageInput;
};

/** Autogenerated return type of PracticeSurchargeUpdate. */
export type PracticeSurchargeUpdatePayload = {
  __typename: 'PracticeSurchargeUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice: Practice;
};

/** Autogenerated input type of PracticeTrialRenew */
export type PracticeTrialRenewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  /** ISO formatted date */
  trialEndDate: Scalars['Date']['input'];
};

/** Autogenerated return type of PracticeTrialRenew. */
export type PracticeTrialRenewPayload = {
  __typename: 'PracticeTrialRenewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
  userErrors?: Maybe<Array<UserError>>;
};

export type Proposal = {
  __typename: 'Proposal';
  /** The client associated with the proposal (optional) */
  client?: Maybe<Client>;
  /** Slug of the source (e.g. template, proposal) of this proposal */
  createdFrom?: Maybe<Scalars['String']['output']>;
  /** Reference number for the proposal (eg. PROP-0001) */
  displayReferenceNumber: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** Checks to see if we can make updates to this proposal */
  isEditable: Scalars['Boolean']['output'];
  /** The name of the proposal */
  name: Scalars['String']['output'];
  /** The URL that points to the uploaded file. */
  pdfUrl: Scalars['URL']['output'];
  /** If true, the proposal can be previewed while in new or draft state */
  publiclyPreviewable: Scalars['Boolean']['output'];
  /** The mapped recurring transaction (if present) */
  quickbooksRecurringTransaction?: Maybe<QuickbooksRecurringTransaction>;
  /** Signatories for this proposal */
  signatories: Array<ProposalSignatory>;
  /** The proposal state */
  state: ProposalState;
  token: Scalars['String']['output'];
  /** The mapped repeating invoice (if present) */
  xeroRepeatingInvoice?: Maybe<XeroIntegrationRepeatingInvoice>;
};

export type ProposalSignatoriesArgs = {
  filter?: InputMaybe<SignatoryFilter>;
};

/** Autogenerated input type of ProposalBulkCreateFromRecurringTransactions */
export type ProposalBulkCreateFromRecurringTransactionsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  /** Type of Recurring Transaction */
  type?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ProposalBulkCreateFromRecurringTransactions. */
export type ProposalBulkCreateFromRecurringTransactionsPayload = {
  __typename: 'ProposalBulkCreateFromRecurringTransactionsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

/** Autogenerated input type of ProposalBulkCreateFromRepeatingInvoices */
export type ProposalBulkCreateFromRepeatingInvoicesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalBulkCreateFromRepeatingInvoices. */
export type ProposalBulkCreateFromRepeatingInvoicesPayload = {
  __typename: 'ProposalBulkCreateFromRepeatingInvoicesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

/** The connection type for Proposal. */
export type ProposalConnection = {
  __typename: 'ProposalConnection';
  /** A list of edges. */
  edges: Array<ProposalEdge>;
  /** A list of nodes. */
  nodes: Array<Proposal>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ProposalCreateFromQuickbooksRecurringTransaction */
export type ProposalCreateFromQuickbooksRecurringTransactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  /** The ID/Slug of the recurring transaction */
  recurringTransactionId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalCreateFromQuickbooksRecurringTransaction. */
export type ProposalCreateFromQuickbooksRecurringTransactionPayload = {
  __typename: 'ProposalCreateFromQuickbooksRecurringTransactionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** Autogenerated input type of ProposalCreateFromXeroRepeatingInvoice */
export type ProposalCreateFromXeroRepeatingInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  /** The ID/Slug of the repeating invoice */
  repeatingInvoiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalCreateFromXeroRepeatingInvoice. */
export type ProposalCreateFromXeroRepeatingInvoicePayload = {
  __typename: 'ProposalCreateFromXeroRepeatingInvoicePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

/** An edge in a connection. */
export type ProposalEdge = {
  __typename: 'ProposalEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Proposal;
};

export enum ProposalEditor {
  CPE = 'CPE',
  NPE = 'NPE',
}

export type ProposalEditorCustomTemplate = {
  __typename: 'ProposalEditorCustomTemplate';
  appName?: Maybe<Scalars['String']['output']>;
  audits?: Maybe<AuditConnection>;
  authorEntity?: Maybe<Scalars['String']['output']>;
  authorLogoUrl?: Maybe<Scalars['String']['output']>;
  authorName?: Maybe<Scalars['String']['output']>;
  deletedAt?: Maybe<Scalars['DateTime']['output']>;
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  logoUrl?: Maybe<Scalars['String']['output']>;
  longDescription?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  publishComment?: Maybe<Scalars['String']['output']>;
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Publisher's admin user */
  publisher?: Maybe<AdminUser>;
  reference?: Maybe<Scalars['String']['output']>;
  sourceName?: Maybe<Scalars['String']['output']>;
  sourceType: CustomTemplateSourceType;
  templateData: Scalars['JSON']['output'];
  templateYaml: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
  visibility: CustomTemplateVisibilityState;
};

export type ProposalEditorCustomTemplateAuditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type ProposalFilter = {
  nameCont?: InputMaybe<Scalars['String']['input']>;
  stateEq?: InputMaybe<ProposalState>;
};

/** Autogenerated input type of ProposalPaymentMethodAttach */
export type ProposalPaymentMethodAttachInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Payment Method */
  paymentMethodId: Scalars['ID']['input'];
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  /** The ID of the NPE Proposal */
  proposalId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalPaymentMethodAttach. */
export type ProposalPaymentMethodAttachPayload = {
  __typename: 'ProposalPaymentMethodAttachPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

export type ProposalRenewalsImport = {
  __typename: 'ProposalRenewalsImport';
  createdAt: Scalars['DateTime']['output'];
  errors?: Maybe<Array<Scalars['String']['output']>>;
  file: Filestack;
  /** The ID for this import */
  id?: Maybe<Scalars['ID']['output']>;
};

/** Autogenerated input type of ProposalRenewalsImportCreate */
export type ProposalRenewalsImportCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The structure referring to the Filestack file */
  importFile: FilestackInput;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of ProposalRenewalsImportCreate. */
export type ProposalRenewalsImportCreatePayload = {
  __typename: 'ProposalRenewalsImportCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposalRenewalsImport?: Maybe<ProposalRenewalsImport>;
};

/** Autogenerated input type of ProposalSetPreviewable */
export type ProposalSetPreviewableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  /** The ID of the NPE Proposal */
  proposalId: Scalars['ID']['input'];
  /** The value of the publicly previewable flag */
  publiclyPreviewable: Scalars['Boolean']['input'];
};

/** Autogenerated return type of ProposalSetPreviewable. */
export type ProposalSetPreviewablePayload = {
  __typename: 'ProposalSetPreviewablePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  proposal?: Maybe<Proposal>;
};

export type ProposalSignatory = {
  __typename: 'ProposalSignatory';
  id: Scalars['ID']['output'];
  /** Portal proposal url */
  proposalUrl: Scalars['URL']['output'];
  role: SignatoryRoleEnum;
};

export enum ProposalState {
  ACCEPTED = 'ACCEPTED',
  ARCHIVED = 'ARCHIVED',
  AWAITING_ACCEPTANCE = 'AWAITING_ACCEPTANCE',
  COMPLETED = 'COMPLETED',
  DRAFT = 'DRAFT',
  LOST = 'LOST',
  NEW = 'NEW',
}

export type Query = {
  __typename: 'Query';
  client?: Maybe<Client>;
  clients?: Maybe<ClientConnection>;
  codeVersion: Scalars['String']['output'];
  currentUser: AdminUser;
  customTemplate?: Maybe<ProposalEditorCustomTemplate>;
  customTemplates?: Maybe<CustomTemplateConnection>;
  engagement?: Maybe<Engagement>;
  environment: Scalars['String']['output'];
  /** Client Billing Invoice */
  invoice?: Maybe<ClientBillingInvoice>;
  paymentsDisbursal?: Maybe<PaymentsDisbursal>;
  paymentsPayment?: Maybe<PaymentsPayment>;
  paymentsPaymentCollection?: Maybe<PaymentsCollection>;
  paymentsRefund?: Maybe<PaymentsRefund>;
  payout?: Maybe<StripePayout>;
  practice: Practice;
  practices: PracticeConnection;
  /** Returns a Ignition object based on a related external Stripe object ID */
  stripeIdSearch?: Maybe<StripeIdSearchUnionConnection>;
  /** Find a User by UUID */
  user?: Maybe<User>;
  users: UserConnection;
};

export type QueryClientArgs = {
  id: Scalars['ID']['input'];
};

export type QueryClientsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ClientFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type QueryCustomTemplateArgs = {
  id: Scalars['ID']['input'];
};

export type QueryCustomTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<CustomTemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type QueryEngagementArgs = {
  id: Scalars['ID']['input'];
};

export type QueryInvoiceArgs = {
  id: Scalars['ID']['input'];
};

export type QueryPaymentsDisbursalArgs = {
  id: Scalars['ID']['input'];
};

export type QueryPaymentsPaymentArgs = {
  id: Scalars['ID']['input'];
};

export type QueryPaymentsPaymentCollectionArgs = {
  id: Scalars['ID']['input'];
};

export type QueryPaymentsRefundArgs = {
  id: Scalars['ID']['input'];
};

export type QueryPayoutArgs = {
  stripeId: Scalars['ID']['input'];
};

export type QueryPracticeArgs = {
  id: Scalars['ID']['input'];
};

export type QueryPracticesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<PracticeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type QueryStripeIdSearchArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  stripeId: Scalars['String']['input'];
};

export type QueryUserArgs = {
  id: Scalars['ID']['input'];
};

export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type QuickbooksIntegrationLine = {
  __typename: 'QuickbooksIntegrationLine';
  /** Line amount */
  amount: Money;
  /** Description of the line */
  description?: Maybe<Scalars['String']['output']>;
  /** Internal slug of the recuring transaction line */
  id: Scalars['ID']['output'];
  /** Name of associated item (if present) */
  itemName?: Maybe<Scalars['String']['output']>;
  /** Line number */
  lineNum: Scalars['Int']['output'];
  /** Quantity */
  quantity?: Maybe<Scalars['String']['output']>;
  /** Unit price */
  unitPrice: Money;
};

export type QuickbooksRecurringTransaction = {
  __typename: 'QuickbooksRecurringTransaction';
  /** Name of the Customer associated with the recurring transaction */
  customerName?: Maybe<Scalars['String']['output']>;
  /** When do we finish invoicing (optional) */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** Internal slug of the recurring transaction */
  id: Scalars['ID']['output'];
  /** Interval type */
  intervalType?: Maybe<Scalars['String']['output']>;
  /** List of Quickbooks Recurring Transaction Lines */
  lines?: Maybe<Array<QuickbooksIntegrationLine>>;
  /** Max occurences (optional) */
  maxOccurences?: Maybe<Scalars['Int']['output']>;
  /** When is the next transaction being generated */
  nextDate?: Maybe<Scalars['Date']['output']>;
  /** The interval based on the interval type. */
  numInterval?: Maybe<Scalars['Int']['output']>;
  /** Mapped Proposal */
  proposal?: Maybe<Proposal>;
  /** External Quickbooks ID of the recurring transaction */
  quickbooksId: Scalars['String']['output'];
  /** Automated, Reminded or Unscheduled */
  recurType?: Maybe<Scalars['String']['output']>;
  /** Name of the Recurring Transaction */
  recurringTemplateName?: Maybe<Scalars['String']['output']>;
  /** Total amount */
  totalAmount: Money;
  /** Type of Recurring Transaction (Bill, Deposit, Invoice, RefundReceipt, SalesReceipt, Transfer etc) */
  type: Scalars['String']['output'];
};

/** The connection type for QuickbooksRecurringTransaction. */
export type QuickbooksRecurringTransactionConnection = {
  __typename: 'QuickbooksRecurringTransactionConnection';
  /** A list of edges. */
  edges: Array<QuickbooksRecurringTransactionEdge>;
  /** A list of nodes. */
  nodes: Array<QuickbooksRecurringTransaction>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type QuickbooksRecurringTransactionEdge = {
  __typename: 'QuickbooksRecurringTransactionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: QuickbooksRecurringTransaction;
};

export type RecipientGroup = {
  __typename: 'RecipientGroup';
  audits?: Maybe<AuditConnection>;
  emailAddresses: Array<Scalars['EmailAddress']['output']>;
  name: Scalars['String']['output'];
};

export type RecipientGroupAuditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for RecipientGroup. */
export type RecipientGroupConnection = {
  __typename: 'RecipientGroupConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RecipientGroupEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RecipientGroup>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RecipientGroupEdge = {
  __typename: 'RecipientGroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<RecipientGroup>;
};

export type RecipientGroupFilter = {
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of ReferralCopyUpdate */
export type ReferralCopyUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  practiceId: Scalars['ID']['input'];
  title: Scalars['String']['input'];
};

/** Autogenerated return type of ReferralCopyUpdate. */
export type ReferralCopyUpdatePayload = {
  __typename: 'ReferralCopyUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  referralCopy: CustomerSuccessReferralCopy;
};

export type RefundsFilter = {
  state?: InputMaybe<PaymentsRefundState>;
};

export type RenewalsImport = {
  __typename: 'RenewalsImport';
  /** When the import file was uploaded */
  createdAt: Scalars['DateTime']['output'];
  /** Validation errors */
  errors?: Maybe<Array<Scalars['String']['output']>>;
  /** Filestack reference and details */
  file: Filestack;
  /** The ID for this Renewals import */
  id: Scalars['ID']['output'];
  state: RenewalsImportState;
  /** Type of Renewals import */
  type: RenewalsImportType;
};

/** The connection type for RenewalsImport. */
export type RenewalsImportConnection = {
  __typename: 'RenewalsImportConnection';
  /** A list of edges. */
  edges: Array<RenewalsImportEdge>;
  /** A list of nodes. */
  nodes: Array<RenewalsImport>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RenewalsImportEdge = {
  __typename: 'RenewalsImportEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: RenewalsImport;
};

export type RenewalsImportFilter = {
  fileTypeEq?: InputMaybe<RenewalsImportType>;
  stateIn?: InputMaybe<Array<RenewalsImportState>>;
};

export enum RenewalsImportState {
  FAILED = 'FAILED',
  IMPORTED = 'IMPORTED',
  PENDING = 'PENDING',
  VALIDATED = 'VALIDATED',
}

export enum RenewalsImportType {
  CLIENTS = 'CLIENTS',
}

/** An uploaded image which may be dynamically resized. */
export type ResizeableImage = {
  __typename: 'ResizeableImage';
  /** The filename of the uploaded image. */
  filename: Scalars['String']['output'];
  /** The mimetype of the uploaded, if available. */
  mimetype?: Maybe<Scalars['String']['output']>;
  /** The size of the uploaded image in bytes, if available. */
  size: Scalars['Int']['output'];
  /** The public URL of the uploaded image. */
  url: Scalars['URL']['output'];
};

/** An uploaded image which may be dynamically resized. */
export type ResizeableImageUrlArgs = {
  fit?: InputMaybe<ResizeableImageFit>;
  height?: InputMaybe<Scalars['Int']['input']>;
  width?: InputMaybe<Scalars['Int']['input']>;
};

export enum ResizeableImageFit {
  /**
   * Preserve the aspect ratio, resize the image to be as large as possible while
   * ensuring its dimensions are less than or equal to both those specified.
   */
  CLIP = 'CLIP',
  /** Preserve the aspect ratio, ensure the image covers both provided dimensions by clipping/cropping to fit. */
  CROP = 'CROP',
  /** Ignore the aspect ratio of the provided image and stretch to both provided dimensions. */
  MAX = 'MAX',
  /** Do not enlarge if the dimensions of the provided image are already less than the specified width or height. */
  SCALE = 'SCALE',
}

export type RevenueBracket = {
  __typename: 'RevenueBracket';
  label: Scalars['String']['output'];
  value: MaturityIndexRevenueBracketValueEnum;
};

export type ServiceFilter = {
  activeEngaged?: InputMaybe<Scalars['Boolean']['input']>;
  nameCont?: InputMaybe<Scalars['String']['input']>;
  recurringEngaged?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ServiceType = {
  __typename: 'ServiceType';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  /** The slug of the Service */
  slug: Scalars['ID']['output'];
};

/** The connection type for ServiceType. */
export type ServiceTypeConnection = {
  __typename: 'ServiceTypeConnection';
  /** A list of edges. */
  edges: Array<ServiceTypeEdge>;
  /** A list of nodes. */
  nodes: Array<ServiceType>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ServiceTypeEdge = {
  __typename: 'ServiceTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: ServiceType;
};

export enum SetSubscriptionPlanNameEnums {
  BOOKKEEPER = 'BOOKKEEPER',
  CORE = 'CORE',
  PRO = 'PRO',
  PROPLUS = 'PROPLUS',
}

export type SignatoryFilter = {
  role?: InputMaybe<SignatoryRoleEnum>;
};

export enum SignatoryRoleEnum {
  PRIMARY = 'PRIMARY',
  SECONDARY = 'SECONDARY',
}

export enum StaffCount {
  /** with a team of 11-20 staff */
  ELEVEN_TO_TWENTY = 'ELEVEN_TO_TWENTY',
  /** with a team of 50+ staff */
  FIFTY_PLUS = 'FIFTY_PLUS',
  /** with a team of 4-5 staff */
  FOUR_TO_FIVE = 'FOUR_TO_FIVE',
  /** with a team of 1-3 staff */
  ONE_TO_THREE = 'ONE_TO_THREE',
  /** with a team of 6-10 staff */
  SIX_TO_TEN = 'SIX_TO_TEN',
  /** as a sole trader */
  SOLE = 'SOLE',
  /** with a team of 21-50 staff */
  TWENTY_ONE_TO_FIFTY = 'TWENTY_ONE_TO_FIFTY',
}

export type StripeCharge = {
  __typename: 'StripeCharge';
  amount: Money;
  collection?: Maybe<PaymentsCollection>;
  dashboardUri: Scalars['URL']['output'];
  id: Scalars['ID']['output'];
  reason?: Maybe<Scalars['String']['output']>;
  status: Scalars['String']['output'];
  stripeId: Scalars['ID']['output'];
};

/** The connection type for StripeCharge. */
export type StripeChargeConnection = {
  __typename: 'StripeChargeConnection';
  /** A list of edges. */
  edges: Array<StripeChargeEdge>;
  /** A list of nodes. */
  nodes: Array<StripeCharge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type StripeChargeEdge = {
  __typename: 'StripeChargeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: StripeCharge;
};

/** Possible result type of a stripe ID lookup */
export type StripeIdSearchUnion =
  | Client
  | ClientBillingInvoice
  | PaymentsDisbursal
  | Practice;

/** The connection type for StripeIdSearchUnion. */
export type StripeIdSearchUnionConnection = {
  __typename: 'StripeIdSearchUnionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<StripeIdSearchUnionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<StripeIdSearchUnion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type StripeIdSearchUnionEdge = {
  __typename: 'StripeIdSearchUnionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<StripeIdSearchUnion>;
};

export type StripeIntegrationAccount = {
  __typename: 'StripeIntegrationAccount';
  bacsDebitSun?: Maybe<BacsDebitSunType>;
  dashboardUri: Scalars['URL']['output'];
  id: Scalars['ID']['output'];
  stripeId: Scalars['String']['output'];
};

export type StripePayout = {
  __typename: 'StripePayout';
  account: StripeIntegrationAccount;
  amount: Money;
  availableOn?: Maybe<Scalars['DateTime']['output']>;
  charges?: Maybe<StripeChargeConnection>;
  dashboardUri: Scalars['URL']['output'];
  disbursal?: Maybe<PaymentsDisbursal>;
  id: Scalars['ID']['output'];
  paidAt?: Maybe<Scalars['DateTime']['output']>;
  stripeId: Scalars['ID']['output'];
};

export type StripePayoutChargesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export enum SubscriptionStatus {
  EXPIRED = 'EXPIRED',
  SUBSCRIBED = 'SUBSCRIBED',
  TRIAL = 'TRIAL',
}

export type Template = {
  __typename: 'Template';
  /** Content of the template */
  content?: Maybe<Scalars['String']['output']>;
  /** Description of the template */
  description?: Maybe<Scalars['String']['output']>;
  /** The slug for this template */
  id: Scalars['ID']['output'];
  /** Is the template the default template */
  isDefault: Scalars['Boolean']['output'];
  /** User's name of the template */
  name: Scalars['String']['output'];
  /** Subject text of the template */
  subject?: Maybe<Scalars['String']['output']>;
  /** System's name of the template */
  systemName?: Maybe<Scalars['String']['output']>;
  /** Summary of tags used in the Content of this template */
  tagsUsed?: Maybe<Scalars['String']['output']>;
  /** Type of the template */
  templateType: Scalars['String']['output'];
  /** Previous versions of the template */
  versions?: Maybe<Array<TemplateVersion>>;
};

/** The connection type for Template. */
export type TemplateConnection = {
  __typename: 'TemplateConnection';
  /** A list of edges. */
  edges: Array<TemplateEdge>;
  /** A list of nodes. */
  nodes: Array<Template>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TemplateEdge = {
  __typename: 'TemplateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Template;
};

export type TemplateFilter = {
  templateTypeEq?: InputMaybe<TemplateType>;
  templateTypeIn?: InputMaybe<Array<TemplateType>>;
};

export enum TemplateType {
  EMAIL = 'EMAIL',
  ENGAGEMENT = 'ENGAGEMENT',
  MESSAGE = 'MESSAGE',
  SYSTEM = 'SYSTEM',
}

export type TemplateVersion = {
  __typename: 'TemplateVersion';
  /** Content of this template version */
  content?: Maybe<Scalars['String']['output']>;
  /** Date this template version was saved */
  date: Scalars['DateTime']['output'];
  /** The ID of this template version */
  id: Scalars['ID']['output'];
  /** Sequence number of this template version */
  number: Scalars['ID']['output'];
  /** Summary of tags used in the Content of this template version */
  tagsUsed?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of TextileConvertLegacyTextile */
export type TextileConvertLegacyTextileInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Legacy Textile (with Liquid) */
  legacyTextile: Scalars['String']['input'];
};

/** Autogenerated return type of TextileConvertLegacyTextile. */
export type TextileConvertLegacyTextilePayload = {
  __typename: 'TextileConvertLegacyTextilePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  html: Scalars['String']['output'];
};

/** A representation of a time zone. */
export type TimeZone = {
  __typename: 'TimeZone';
  /** The standard ICANN tz database code (e.g. 'America/New_York') */
  code: Scalars['String']['output'];
  /** The friendly (Rails compatible) time zone name (e.g. 'Eastern Time (US & Canada)') */
  name: Scalars['String']['output'];
  /** Formatted UTC offset. */
  utcOffset: Scalars['String']['output'];
  /** The UTC offset in seconds. */
  utcOffsetInSeconds: Scalars['Int']['output'];
};

export type Token = {
  __typename: 'Token';
  accessToken: Scalars['String']['output'];
  client: Scalars['ID']['output'];
  uid: Scalars['String']['output'];
};

export enum TwoFactorAuthMethod {
  AUTH_APP = 'AUTH_APP',
  SMS = 'SMS',
}

export type User = {
  __typename: 'User';
  active: Scalars['Boolean']['output'];
  audits?: Maybe<AuditConnection>;
  avatarUrl?: Maybe<Scalars['URL']['output']>;
  createdAt: Scalars['DateTime']['output'];
  /** Time stamp of the user's current/ most recent sign in */
  currentSignInAt?: Maybe<Scalars['DateTime']['output']>;
  /** IP address of the user's current/ most recent sign in */
  currentSignInIp?: Maybe<Scalars['IpAddress']['output']>;
  emailAddress: Scalars['EmailAddress']['output'];
  fullName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  importedId?: Maybe<Scalars['ID']['output']>;
  invitationAcceptedAt?: Maybe<Scalars['DateTime']['output']>;
  invitationSentAt?: Maybe<Scalars['DateTime']['output']>;
  isPrincipal: Scalars['Boolean']['output'];
  jobTitle?: Maybe<Scalars['String']['output']>;
  /** Time stamp of the user's previous sign in */
  lastSignInAt?: Maybe<Scalars['DateTime']['output']>;
  /** IP address of the user's previous sign in */
  lastSignInIp?: Maybe<Scalars['IpAddress']['output']>;
  practice: Practice;
  role?: Maybe<Scalars['String']['output']>;
  signInCount: Scalars['Int']['output'];
  twoFactorAuthEnabled: Scalars['Boolean']['output'];
  twoFactorAuthMethod?: Maybe<TwoFactorAuthMethod>;
  twoFactorAuthMobile?: Maybe<Scalars['PhoneNumber']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};

export type UserAuditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for User. */
export type UserConnection = {
  __typename: 'UserConnection';
  /** A list of edges. */
  edges: Array<UserEdge>;
  /** A list of nodes. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of UserDelete */
export type UserDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  /** The ID of the User */
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of UserDelete. */
export type UserDeletePayload = {
  __typename: 'UserDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
  userErrors?: Maybe<Array<UserError>>;
};

/** An edge in a connection. */
export type UserEdge = {
  __typename: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: User;
};

export type UserError = {
  __typename: 'UserError';
  /** Path to the input field which caused the error */
  field?: Maybe<Array<Scalars['String']['output']>>;
  /** The error message */
  message: Scalars['String']['output'];
};

export type UserFilter = {
  emailCont?: InputMaybe<Scalars['String']['input']>;
  nameCont?: InputMaybe<Scalars['String']['input']>;
};

export type UserInputType = {
  emailAddress?: InputMaybe<Scalars['EmailAddress']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated input type of UserResetTfa */
export type UserResetTfaInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  /** The ID of the User */
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of UserResetTfa. */
export type UserResetTfaPayload = {
  __typename: 'UserResetTfaPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Autogenerated input type of UserTokenGenerate */
export type UserTokenGenerateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the User */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UserTokenGenerate. */
export type UserTokenGeneratePayload = {
  __typename: 'UserTokenGeneratePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  token: Token;
};

/** Autogenerated input type of UserUpdate */
export type UserUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
  user: UserInputType;
};

/** Autogenerated return type of UserUpdate. */
export type UserUpdatePayload = {
  __typename: 'UserUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
  userErrors?: Maybe<Array<UserError>>;
};

export type XeroIntegrationLineItem = {
  __typename: 'XeroIntegrationLineItem';
  /** Whether or not the repeating invoice line item was deleted. */
  deleted?: Maybe<Scalars['Boolean']['output']>;
  /** Description of the line item */
  description: Scalars['String']['output'];
  /** Discount amount */
  discountAmount: Money;
  /** Discount rate */
  discountRate?: Maybe<Scalars['Float']['output']>;
  /** Internal slug of the repeating invoice line item */
  id: Scalars['ID']['output'];
  /** Item code */
  itemCode?: Maybe<Scalars['String']['output']>;
  /** Name of associated item (if present) */
  itemName?: Maybe<Scalars['String']['output']>;
  /** Line amount */
  lineAmount: Money;
  /** Quantity */
  quantity?: Maybe<Scalars['Float']['output']>;
  /** Tax amount */
  taxAmount: Money;
  /** Tax Type */
  taxType?: Maybe<Scalars['String']['output']>;
  /** Unit amount */
  unitAmount: Money;
};

export type XeroIntegrationRepeatingInvoice = {
  __typename: 'XeroIntegrationRepeatingInvoice';
  /** Name of the Contact associated with the repeating invoice */
  contactName?: Maybe<Scalars['String']['output']>;
  /** Whether or not the repeating invoice was deleted. */
  deleted?: Maybe<Scalars['Boolean']['output']>;
  /** When do we finish invoicing (optional) */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** Internal slug of the repeating invoice */
  id: Scalars['ID']['output'];
  /** List of Xero Repeating Invoice Line Items */
  lineItems?: Maybe<Array<XeroIntegrationLineItem>>;
  /** When is the next invoice being generated */
  nextScheduledDate: Scalars['Date']['output'];
  /** Weekly or monthly frequency */
  period: Scalars['Int']['output'];
  /** Mapped Proposal */
  proposal?: Maybe<Proposal>;
  /** Total cost */
  total: Money;
  /** WEEKLY or MONTHLY */
  unit: Scalars['String']['output'];
  /** Customer added string to refer to the repeating invoice */
  xeroReference?: Maybe<Scalars['String']['output']>;
  /** External Xero ID of the repeating invoice */
  xeroRepeatingInvoiceId: Scalars['String']['output'];
};

/** The connection type for XeroIntegrationRepeatingInvoice. */
export type XeroIntegrationRepeatingInvoiceConnection = {
  __typename: 'XeroIntegrationRepeatingInvoiceConnection';
  /** A list of edges. */
  edges: Array<XeroIntegrationRepeatingInvoiceEdge>;
  /** A list of nodes. */
  nodes: Array<XeroIntegrationRepeatingInvoice>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type XeroIntegrationRepeatingInvoiceEdge = {
  __typename: 'XeroIntegrationRepeatingInvoiceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: XeroIntegrationRepeatingInvoice;
};

/** Autogenerated input type of practiceBillingSetSubscription */
export type PracticeBillingSetSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  plan?: InputMaybe<SetSubscriptionPracticeBillingPlanInput>;
  /** The ID of the Practice */
  practiceId: Scalars['ID']['input'];
};

/** Autogenerated return type of practiceBillingSetSubscription. */
export type PracticeBillingSetSubscriptionPayload = {
  __typename: 'practiceBillingSetSubscriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  practice?: Maybe<Practice>;
};

export type SetSubscriptionPracticeBillingPlanInput = {
  frequency: PracticeBillingPlanFrequency;
  planName: SetSubscriptionPlanNameEnums;
};

export type PracticeQueryVariables = Types.Exact<{
  id: Types.Scalars['ID']['input'];
}>;

export type PracticeQuery = {
  __typename: 'Query';
  practice: {
    __typename: 'Practice';
    id: string;
    referenceNumber: string;
    paymentSettings: {
      __typename: 'PaymentsSettings';
      isCollectionsEnabled: boolean;
      isDisbursalsEnabled: boolean;
      onboardedPreset?: Types.PaymentsOnboardedPresetType | null;
    };
    plan?: { __typename: 'Plan'; name: string } | null;
    stripeIntegrationAccount?: {
      __typename: 'StripeIntegrationAccount';
      dashboardUri: any;
    } | null;
  };
};

export const PracticeDocument = gql`
  query practice($id: ID!) {
    practice(id: $id) {
      id
      referenceNumber
      paymentSettings {
        isCollectionsEnabled
        isDisbursalsEnabled
        onboardedPreset
      }
      plan {
        name
      }
      stripeIntegrationAccount {
        dashboardUri
      }
    }
  }
`;

export type SdkFunctionWrapper = <T>(
  action: (requestHeaders?: Record<string, string>) => Promise<T>,
  operationName: string,
  operationType?: string
) => Promise<T>;

const defaultWrapper: SdkFunctionWrapper = (
  action,
  _operationName,
  _operationType
) => action();

export function practiceQuerySdk(
  client: GraphQLClient,
  withWrapper: SdkFunctionWrapper = defaultWrapper
) {
  return {
    practice(
      variables: PracticeQueryVariables,
      requestHeaders?: Dom.RequestInit['headers']
    ): Promise<PracticeQuery> {
      return withWrapper(
        (wrappedRequestHeaders) =>
          client.request<PracticeQuery>(PracticeDocument, variables, {
            ...requestHeaders,
            ...wrappedRequestHeaders,
          }),
        'practice',
        'query'
      );
    },
  };
}

export type Sdk = ReturnType<typeof practiceQuerySdk>;
